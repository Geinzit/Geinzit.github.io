<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC自动机</title>
    <url>/posts/41192.html</url>
    <content><![CDATA[<p>若不熟悉KMP算法，强烈建议好好先去了解一下，否则这里会有很多不大理解的思想。</p>
<h2 id="trie树上的kmp">Trie树上的KMP?</h2>
<p>想想原本的<span
class="math inline">\(KMP\)</span>算法，为了快速匹配，我们根据匹配串先预处理一个<span
class="math inline">\(next[]\)</span>数组，也就是最长的后缀与前缀完全匹配的位置，然后一旦遇到匹配错误的时候，就把当时的匹配指针移到他的<span
class="math inline">\(next[]\)</span>即可。</p>
<p>那么想想，如果有多个匹配串和一个文本串，要求你在文本串中找出能匹配到多少个串。那么想想，如果关于所有匹配串建立一颗<span
class="math inline">\(Trie\)</span>树，在这个上面进行<span
class="math inline">\(KMP\)</span>算法是否可行呢？</p>
<h2 id="例题">例题：</h2>
<h3 id="keywords-search-hdu-2222">Keywords Search （HDU-2222）</h3>
<h3 id="题目描述">题目描述</h3>
<p><strong>czh</strong>在成千上万次尝试后，终于被自己感动了，他决定换一种方式来理解<strong>cry</strong>的文章，他列举出自己掌握的所有单词，来统计词频，可是<strong>czh</strong>已经累了，不想动了，只能瘫在椅子上给你们加油了。
<span id="more"></span></p>
<h3 id="输入">输入</h3>
<p>第一行一个正整数表示数据组数
每组第一行一个正整数N表示czh掌握的单词数量N&lt;=10000
接下来每行一个字符串表示掌握的单词，每个单词只包含小写字母，长度不超过50
最后一行为文章字符串，长度不超过1000000</p>
<h3 id="输出">输出</h3>
<p>每组数据输出一行，每行一个数字表示文章中出现了几个czh掌握的单词。</p>
<h4 id="样例输入">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">ate</span><br><span class="line">at</span><br><span class="line">eat</span><br><span class="line">tea</span><br><span class="line">year</span><br><span class="line">hyeateart</span><br></pre></td></tr></table></figure>
<h4 id="样例输出">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="思路">思路：</h2>
<p>这是一道AC自动机的裸题。就像前面所说的在<span
class="math inline">\(Trie\)</span>树上进行<span
class="math inline">\(KMP\)</span>匹配。那么首先自然就是<span
class="math inline">\(Trie\)</span>树的建立。写法如下（当然，不是唯一写法）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">	void init()&#123;loop(i,26)son[i]=0;cnt=0;fail=0;&#125;</span><br><span class="line">	int son[26],cnt,fail;</span><br><span class="line">&#125;T[M];</span><br><span class="line">void insert(char str[])&#123;</span><br><span class="line">	int len=strlen(str);</span><br><span class="line">	int cur=0;</span><br><span class="line">	loop(i,len)&#123;</span><br><span class="line">		int x=str[i]-&#x27;a&#x27;;</span><br><span class="line">		if(!T[cur].son[x])T[cur].son[x]=++sz,T[sz].init();</span><br><span class="line">		cur=T[cur].son[x];</span><br><span class="line">	&#125;</span><br><span class="line">	T[cur].cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 接下来就是AC自动机的精髓了，就是fail数组的预处理了。<span
class="math inline">\(fail\)</span>数组就是<span
class="math inline">\(KMP\)</span>算法中的<span
class="math inline">\(next\)</span>数组。由于每个从<span
class="math inline">\(Trie\)</span>树根到某一个节点都对应一个前缀，那么如果匹配失败的话就跳回后缀与前缀相等的最大长度的位置。那么预处理fail则是如此：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T[T[x].son[i]].fail=T[T[x].fail].son[i];</span><br></pre></td></tr></table></figure> 但是如果<span
class="math inline">\(T[x].son[i]\)</span>为空的话，那么就把他指向他的<span
class="math inline">\(fail\)</span>位置的儿子： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T[x].son[i]=T[T[x].fail].son[i];</span><br></pre></td></tr></table></figure>
经过这样的操作，若是对一个文本串的预处理，就只需要跳他的儿子即可。</p>
<p>最后就是遍历<span
class="math inline">\(Trie\)</span>树的顺序，只需要用一个队列进行类<span
class="math inline">\(bfs\)</span>操作即可。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ac_automation()&#123;</span><br><span class="line">	loop(i,26)if(T[0].son[i])T[T[0].son[i]].fail=0,Q.push(T[0].son[i]);//将根节点的儿子推进队列</span><br><span class="line">	while(!Q.empty())&#123;</span><br><span class="line">		int x=Q.front();Q.pop();</span><br><span class="line">		loop(i,26)&#123;</span><br><span class="line">			if(T[x].son[i])T[T[x].son[i]].fail=T[T[x].fail].son[i],Q.push(T[x].son[i]);</span><br><span class="line">			else T[x].son[i]=T[T[x].fail].son[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个写法比较，不过个人认为我的写法是比较简单的，仔细理解。</p>
<p>最后就是对文本串的匹配，每次直接跳儿子，每次若是遇到一个匹配串的结尾，就将其计入答案，同时每次跳<span
class="math inline">\(fail\)</span>节点的时候，将其标记掉没下次就不跳了，因为跳过后所有可能的点都已被计入答案了，于是最终代码便是如此：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Query()&#123;</span><br><span class="line">	int len=strlen(S);</span><br><span class="line">	int cur=0,ans=0;</span><br><span class="line">	loop(i,len)&#123;</span><br><span class="line">		cur=T[cur].son[S[i]-&#x27;a&#x27;];</span><br><span class="line">		for(int j=cur;j&amp;&amp;~T[j].cnt;j=T[j].fail)ans+=T[j].cnt,T[j].cnt=-1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那么这样这道题就做出来了，总体还是比较简单的，最终代码如下：</p>
<h4 id="代码">代码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define FOR(i,l,r) for(int i=l,END=r;i&lt;=END;i++)</span><br><span class="line">#define DOR(i,r,l) for(int i=r,END=l;i&gt;=END;i--)</span><br><span class="line">#define loop(i,n) for(int i=0,END=n;i&lt;END;i++)</span><br><span class="line">#define sf scanf</span><br><span class="line">#define pf printf</span><br><span class="line">#define mms(a,x) memset(a,x,sizeof a)</span><br><span class="line">using namespace std;</span><br><span class="line">const int M=1e6+5;</span><br><span class="line">int n;</span><br><span class="line">char str[M],S[M];</span><br><span class="line">struct Trie&#123;</span><br><span class="line">	int sz;</span><br><span class="line">	queue&lt;int&gt;Q;</span><br><span class="line">	struct node&#123;</span><br><span class="line">		void init()&#123;loop(i,26)son[i]=0;cnt=0;fail=0;&#125;</span><br><span class="line">		int son[26],cnt,fail;</span><br><span class="line">	&#125;T[M];</span><br><span class="line">	void insert(char str[])&#123;//插入匹配串</span><br><span class="line">		int len=strlen(str);</span><br><span class="line">		int cur=0;</span><br><span class="line">		loop(i,len)&#123;</span><br><span class="line">			int x=str[i]-&#x27;a&#x27;;</span><br><span class="line">			if(!T[cur].son[x])T[cur].son[x]=++sz,T[sz].init();</span><br><span class="line">			cur=T[cur].son[x];</span><br><span class="line">		&#125;</span><br><span class="line">		T[cur].cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	void ac_automation()&#123;//预处理fail</span><br><span class="line">		loop(i,26)if(T[0].son[i])T[T[0].son[i]].fail=0,Q.push(T[0].son[i]);</span><br><span class="line">		while(!Q.empty())&#123;</span><br><span class="line">			int x=Q.front();Q.pop();</span><br><span class="line">			loop(i,26)&#123;</span><br><span class="line">				if(T[x].son[i])T[T[x].son[i]].fail=T[T[x].fail].son[i],Q.push(T[x].son[i]);</span><br><span class="line">				else T[x].son[i]=T[T[x].fail].son[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int Query()&#123;//查询答案</span><br><span class="line">		int len=strlen(S);</span><br><span class="line">		int cur=0,ans=0;</span><br><span class="line">		loop(i,len)&#123;</span><br><span class="line">			cur=T[cur].son[S[i]-&#x27;a&#x27;];</span><br><span class="line">			for(int j=cur;j&amp;&amp;~T[j].cnt;j=T[j].fail)ans+=T[j].cnt,T[j].cnt=-1;//标记掉路径</span><br><span class="line">		&#125;</span><br><span class="line">		return ans;</span><br><span class="line">	&#125;</span><br><span class="line">	void init()&#123;</span><br><span class="line">		sz=0;</span><br><span class="line">		T[0].init();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Tr;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int T;</span><br><span class="line">	sf(&quot;%d&quot;,&amp;T);</span><br><span class="line">	while(T--)&#123;</span><br><span class="line">		Tr.init();</span><br><span class="line">		sf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		FOR(i,1,n)&#123;</span><br><span class="line">			sf(&quot;%s&quot;,str);</span><br><span class="line">			Tr.insert(str);</span><br><span class="line">		&#125;</span><br><span class="line">		Tr.ac_automation();</span><br><span class="line">		sf(&quot;%s&quot;,S);</span><br><span class="line">		pf(&quot;%d\n&quot;,Tr.Query());</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>IdealString（Topcoder 9757）</title>
    <url>/posts/35861.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>一个理想字符串的定义是<strong>每个字符第一个出现的位置编号就是等于这个字符出现的次数</strong>，比如
<strong>ABOOOB</strong>就是一个理想字符串(<strong>A</strong>第一次出现的位置是<strong>1</strong>，一共有一个<strong>1</strong>，<strong>O</strong>最早出现的位置是<strong>3</strong>，一共有三个<strong>O</strong>,<strong>B</strong>第一次出现的位置为<strong>2</strong>，一共有<strong>2</strong>个<strong>B</strong>)。给定长度<strong>length</strong>，返回字典序最小的理想字符串，如果没有，则返回空串</p>
<span id="more"></span>
<h2 id="输入">输入</h2>
<p>一个长度length,length&lt;=100</p>
<h2 id="输出">输出</h2>
<p>输出该字符串</p>
<h2 id="思路">思路：</h2>
<h4 id="题意分析">题意分析</h4>
<p>这题只要把题意稍微转化一下就会变得比较简单：若在 <span
class="math inline">\(p\)</span>位置放一个字符，那么就会出现<span
class="math inline">\(p\)</span>个相同的字符，那么若所有的字符第一次出现的位置为<span
class="math inline">\([p1,p2..pm]\)</span>,那么必定满足<span
class="math inline">\(p1+p2+..+pm\)</span>等于<span
class="math inline">\(length\)</span>，有因为length的范围比较小那么可以考虑直接深搜。</p>
<h4 id="深搜策略">深搜策略</h4>
<p>说策略，其实也没啥策略，<del>因为范围实在太小啦</del>，注意的就是<strong>每次放下一个新的字符的位置是有范围的</strong>，不能超过上一个位置的两倍，也不能超过<span
class="math inline">\(length\)</span>的一半，否则都不符合条件，具体原因自行思考,又由于字符串的字典序要最小所以每次放新的字符位置要尽可能远（当然先放A，再放B…）。<br />
当最后得到每个第一位置后，最后就是组成字符串了，这个其实用一个队列就ok了，比较简单。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(int)l;i&lt;=(int)r;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(int)r;i&gt;=(int)l;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0;i&lt;(int)n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">queue&lt;<span class="type">char</span>&gt;Q;</span><br><span class="line"><span class="type">int</span> a[N],len,found=<span class="number">0</span>,L;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">string ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> x,<span class="type">int</span> cnt)</span></span>&#123;<span class="comment">//剩余字符数量，上一个位置，用了几个字符 </span></span><br><span class="line"><span class="comment">//	printf(&quot;sum:%d x:%d cnt:%d\n&quot;,sum,x,cnt);</span></span><br><span class="line">	<span class="keyword">if</span>(sum&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">			<span class="built_in">FOR</span>(j,<span class="number">1</span>,a[i]<span class="number">-1</span>)Q.<span class="built_in">push</span>(i+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>); </span><br><span class="line">			s[a[i]<span class="number">-1</span>]=i+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>;<span class="comment">//放第一个位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">loop</span>(i,L)<span class="keyword">if</span>(!s[i])s[i]=Q.<span class="built_in">front</span>(),Q.<span class="built_in">pop</span>();<span class="comment">//用队列组成字符串 </span></span><br><span class="line">		found=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DOR</span>(i,<span class="built_in">min</span>(sum,<span class="built_in">min</span>(x+x==<span class="number">0</span>?<span class="number">1</span>:x+x,(L+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)),x+<span class="number">1</span>)&#123;<span class="comment">//枚举下一个字符的位置，由于要尽可能远所以倒着枚举 </span></span><br><span class="line">		a[cnt+<span class="number">1</span>]=i;<span class="comment">//记录第一个位置 </span></span><br><span class="line">		<span class="built_in">dfs</span>(sum-i,i,cnt+<span class="number">1</span>);</span><br><span class="line">		a[cnt+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(found)<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IdealString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">construct</span><span class="params">(<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">		L=length,<span class="built_in">mms</span>(s,<span class="number">0</span>),ans.<span class="built_in">clear</span>();</span><br><span class="line">		found=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(L,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(found)ans=s;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Constructing Chimney（HDU-4332）</title>
    <url>/posts/24488.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>Now we are planning to construct a big chimney. The chimney’s section
is a 3×3 square and the center of it will have nothing like the picture
below. Now we only have a lot of bricks whose size if 1×1×2, and we want
to build a chimney whose height is N, so can help us to calculate how
many ways we can build the chimney? The answer may be very large, so you
can just tell the answer’s remainder divided by 1000000007.</p>
<p><img src="http://acm.hdu.edu.cn/data/images/C401-1002-1.jpg" /></p>
<p>用1×1×2的砖头摆出如图所示的烟囱，可以横着摆也可以竖着摆，求摆出n层高的烟囱会有多少种不同的方案。
<span id="more"></span> ## 思路：
这题其实最难想的就是dp转移，变态的细节非常的多。</p>
<p>首先要考虑的就是状态定义，若是一层一层的进行转移我们都考虑他们所在当前层的状态，<strong>我们用一个8位二进制数来表示当前层的状态，当然，1表示砖，0表示没有砖。</strong></p>
<p>若是暴力转移我们便有： <span
class="math inline">\(dp[i][stat]=dp[i-1][stat2]*met[stat][stat2]\)</span></p>
<p>注意<span
class="math inline">\(met[stat][stat2]\)</span>表示<strong>状态由当前层的stat2到下一层的stat的方案数</strong></p>
<p>若是直接这样转移，复杂度绝对爆炸，所以就考虑用矩阵乘法快速幂来进行操作。</p>
<p>不过在开始定义矩阵时，先想一想：就算使用矩阵优化，复杂度也是<span
class="math inline">\(O(256^3*log(n))\)</span>,还是很可能会超时（不过卡常卡的好话或许也可以吧。。个人没试过）。那么咋们看一下这<span
class="math inline">\(256\)</span>个状态（毕竟那个log也没什么好优化的），应该比较好想到<strong>所有<span
class="math inline">\(1\)</span>的个数为奇数个的状态都是无效的</strong>，因为这样就无法把当前层填满而又不会填到下一层了。这样复杂度就够了，不过好像可以再把所有旋转相同的状态也去掉，使得最后只有七十多种状态，不过旋转判定有点复杂，我就懒得想了。。。</p>
<p>最后就是预处理最初矩阵，其实就是把所有能够相互转移的状态找出，<strong>注意是当前层的状态转移到下一层的状态，所以<span
class="math inline">\(0\)</span>和<span
class="math inline">\(1\)</span>是哪一层的<span
class="math inline">\(0\)</span>和<span
class="math inline">\(1\)</span>分清楚</strong>，别的也没什么了，判是否可行的方法有很多，就不在过多赘述了。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=l,END=r;i&lt;=END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=r,END=l;i&gt;=END;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0,END=n;i&lt;END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">1e9</span>+<span class="number">7</span>,N=(<span class="number">1</span>&lt;&lt;<span class="number">8</span>),M=N&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;<span class="comment">//矩阵 </span></span><br><span class="line">	<span class="type">int</span> num[N][N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(num,<span class="number">0</span>);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">clear</span>();<span class="built_in">loop</span>(i,M)num[i][i]=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">loop</span>(i,M)<span class="built_in">loop</span>(j,M)<span class="built_in">pf</span>(<span class="string">&quot;%d%c&quot;</span>,num[i][j],j==M<span class="number">-1</span>?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;A)<span class="type">const</span>&#123;</span><br><span class="line">		Matrix ans;</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">loop</span>(i,M)<span class="built_in">loop</span>(j,M)</span><br><span class="line">			<span class="built_in">loop</span>(k,M)ans.num[i][j]=(ans.num[i][j]+<span class="number">1ll</span>*num[i][k]*A.num[k][j])%P;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Pow[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span>&#123;<span class="keyword">return</span> (x&gt;&gt;pos)&amp;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//判定是否可行 </span></span><br><span class="line">	<span class="type">int</span> mark=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">loop</span>(i,<span class="number">8</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">is1</span>(x,i)&amp;&amp;<span class="built_in">is1</span>(y,i))&#123;<span class="comment">//若在上一层已有，那么只能横着放砖块，所以它的下一位也要是1 </span></span><br><span class="line">			<span class="keyword">if</span>(i&lt;<span class="number">7</span>&amp;&amp;<span class="built_in">is1</span>(x,i+<span class="number">1</span>)&amp;&amp;<span class="built_in">is1</span>(y,i+<span class="number">1</span>))i++;</span><br><span class="line">			<span class="keyword">else</span> &#123;mark--;<span class="keyword">break</span>;&#125;;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">is1</span>(x,i)&amp;&amp;!<span class="built_in">is1</span>(y,i))&#123;mark--;<span class="keyword">break</span>;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	x|=(x&amp;<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">	y|=(y&amp;<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">	<span class="comment">//把第一位移到最后面</span></span><br><span class="line">	<span class="built_in">DOR</span>(i,<span class="number">8</span>,<span class="number">1</span>)&#123;<span class="comment">//到这再来一次，这次能够使第一个和最后一个也考虑到 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">is1</span>(x,i)&amp;&amp;<span class="built_in">is1</span>(y,i))&#123;<span class="comment">//同上</span></span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">is1</span>(x,i<span class="number">-1</span>)&amp;&amp;<span class="built_in">is1</span>(y,i<span class="number">-1</span>))i--;</span><br><span class="line">			<span class="keyword">else</span> &#123;mark--;<span class="keyword">break</span>;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">is1</span>(x,i)&amp;&amp;!<span class="built_in">is1</span>(y,i))&#123;mark--;<span class="keyword">break</span>;&#125;;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mark&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">loop</span>(i,N)&#123;</span><br><span class="line">		<span class="type">int</span> t=i,cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;t;t^=<span class="built_in">lowbit</span>(t))cnt^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!cnt)flag[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> bx=<span class="number">0</span>,by=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">loop</span>(i,N)&#123;<span class="comment">//预处理矩阵 </span></span><br><span class="line">		<span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">			by=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">loop</span>(j,N)<span class="keyword">if</span>(flag[j])</span><br><span class="line">				Pow[<span class="number">0</span>].num[bx][by++]=<span class="built_in">check</span>(i,j);</span><br><span class="line">			bx++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Pow[<span class="number">0</span>].num[M<span class="number">-1</span>][M<span class="number">-1</span>]++;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">32</span>)Pow[i]=Pow[i<span class="number">-1</span>]*Pow[i<span class="number">-1</span>];<span class="comment">//预处理快速幂矩阵 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	Matrix res;</span><br><span class="line">	res.<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">loop</span>(i,<span class="number">32</span>)<span class="keyword">if</span>(<span class="built_in">is1</span>(n,i))res=res*Pow[i];</span><br><span class="line">	<span class="keyword">return</span> res.num[M<span class="number">-1</span>][M<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> T,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">pf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,++kase,<span class="built_in">qpow</span>(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>50 years, 50 colors （HDU-1498）</title>
    <url>/posts/18718.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>On Octorber 21st, HDU 50-year-celebration, 50-color balloons floating
around the campus, it’s so nice, isn’t it? To celebrate this meaningful
day, the ACM team of HDU hold some fuuny games. Especially, there will
be a game named “crashing color balloons”.</p>
<p>There will be a <strong>n^2</strong> matrix board on the ground, and
each grid will have a color balloon in it.And the color of the ballon
will be in the range of <strong>[1, 50]</strong>.After the referee
shouts “go!”,you can begin to crash the balloons.Every time you can only
choose one kind of balloon to crash, we define that the two balloons
with the same color belong to the same kind.What’s more, <strong>each
time you can only choose a single row or column of balloon, and crash
the balloons that with the color you had chosen</strong>. Of course, a
lot of students are waiting to play this game, so we just give every
student <strong>k</strong> times to crash the balloons.</p>
<p>Here comes the problem: which kind of balloon is
<strong>impossible</strong> to be all crashed by a student in
<strong>k</strong> times.</p>
<p><img src="http://acm.hdu.edu.cn/data/images/c48-1008-1.jpg" /></p>
<p>撞气球游戏，一个n*n的矩阵中，有不同颜色的气球，气球的颜色最多50种（从1到50）。
游戏开始前，先选择一种颜色。游戏开始后，每次选择一行或者一列包含该种颜色的气球进行撞击。如果选择行，那么这一行的气球都会炸裂。如果选择列，这一列的气球都炸裂。
请你求出，有多少种颜色的气球，无论怎么玩，都不能在K次之内，把所有同色的气球都撞裂。
<span id="more"></span></p>
<h2 id="输入">输入</h2>
<p>There will be multiple input cases.Each test case begins with two
integers <strong>n, k</strong>. <strong>n</strong> is the number of rows
and columns of the balloons <strong>(1 &lt;= n &lt;= 100)</strong>, and
<strong>k</strong> is the times that ginving to each student<strong>(0
&lt; k &lt;= n)</strong>.Follow a matrix A of **n*n<strong>, where Aij
denote the color of the ballon in the </strong>i<strong> row,
</strong>j<strong> column.Input ends with </strong>n = k = 0**.</p>
<p>有多组数据 每组测试数据，第一行两个整数n和k
接下来n行，每行n个整数，表示该行的气球颜色。 n=k=0时读入结束。</p>
<h2 id="输出">输出</h2>
<p>For each test case, print in ascending order all the colors of which
are impossible to be crashed by a student in <strong>k</strong> times.
<strong>If there is no choice, print “-1”</strong>.</p>
<p>按照升序输出哪些颜色的气球无论怎么玩，都不能在K次之内，把所有同色的气球都撞裂，如果没有，输出-1</p>
<h2 id="思路">思路：</h2>
<blockquote>
<p>想到用二分图去匹配行列</p>
</blockquote>
<p>这题的二分图就比较抽象了，本体实际上的建边方法就是：<strong>枚举每一种气球颜色C，将每行中颜色为C的点连给该行，然后枚举所有行进行匈牙利算法即可</strong>。</p>
<p>为什么呢?这样想：<strong>枚举的是行，匹配到的列就是我们要踩的列。若一个行的所有点都已被匹配，就可理解为它们都已经被处理，也就不用去踩这一行了</strong>。因此这方法是可行的
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> col[N][N],mk[N],n;</span><br><span class="line"><span class="type">bool</span> mark[N],flag[<span class="number">55</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[x][i];</span><br><span class="line">		<span class="keyword">if</span>(mark[v])<span class="keyword">continue</span>;</span><br><span class="line">		mark[v]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mk[v]==<span class="number">-1</span>||<span class="built_in">sp</span>(mk[v]))&#123;</span><br><span class="line">			mk[v]=x;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(mk,<span class="number">-1</span>,<span class="built_in">sizeof</span>(mk));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="built_in">sizeof</span>(mark));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sp</span>(i))ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k)==<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n&amp;&amp;!k)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;col[i][j]),flag[col[i][j]]=<span class="number">1</span>;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;A;A.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">1</span>;c&lt;=<span class="number">50</span>;c++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!flag[c])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)e[i].<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">					<span class="keyword">if</span>(col[i][j]==c)</span><br><span class="line">						e[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">solve</span>()&gt;k)A.<span class="built_in">push_back</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(A.<span class="built_in">size</span>())<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,A[i]);<span class="keyword">if</span>(i+<span class="number">1</span>&lt;A.<span class="built_in">size</span>())<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Lady CA and the graph（HDU-5664）</title>
    <url>/posts/49945.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>Lady CA has a tree with <strong>n</strong> points numbered
<strong>1,2,…,n</strong>, and each edge has its weight. The unique route
connecting two points is called a chain, and the length of a chain
equals the sum value of the weights of the edges passed.</p>
<p>The point number <strong>m</strong> is called the root. Lady CA
defines a special kind of chain called folded chain, the chain
connecting the points numbered <strong>x,y(x≠y)</strong> is called a
folded chain, if and only if the chain connecting the point numbered
<strong>x</strong> and the root doesn’t pass the point numbered
<strong>y</strong>, and the chain connecting the point numbered
<strong>y</strong> and the root doesn’t pass the point numbered
<strong>x</strong>.</p>
<p>Lady CA wants to find the length of the <strong>k</strong>th longest
folded chain. Notice that the chain connecting the points numbered
<strong>x,y</strong> and the chain connecting the points numbered
<strong>y,x</strong> are the same. <span id="more"></span> ## 输入 The first line
contains an integer <strong>T(1≤T≤3)</strong>——The number of the test
cases. For each test case: The first line contains three integers
<strong>n(2≤n≤50,000),m(1≤m≤n),k(1≤k≤n×(n−1)2)</strong>. Between each
two adjacent integers there is a white space separated. The second line
to the nth line describes the n−1 edges in the graph. Each line contains
three integers <strong>u,v(1≤u,v≤n,u≠v),w(1≤w≤10,000)</strong>, which
means there is an edge which has a weight <strong>w</strong> connecting
the points numbered <strong>u,v</strong>. Between each two adjacent
integers there is a white space separated.</p>
<h2 id="输出">输出</h2>
<p>For each test case, the only line contains the only integer that is
the length of the <strong>k</strong>th longest folded chain. If the
<strong>k</strong>th longest folded chain doesn’t exist, print NO.</p>
<h2 id="思路">思路：</h2>
<p>做这题首先需要知道的思想就是：<strong>求一个第k大的值能够转化为二分答案求最大的不小于它的数大于等于k个的值</strong>（这话有点绕但十分重要），它打开我们解这道题的一个通道。</p>
<p>接下来就是求树中大于等于这个值的路径数了，这个自然能想到点分治求解，做法和之前我写的一道题一样（POJ-1741），但是接下来就要考虑到限制条件了，就是路径的两端都不能是另一端的祖先，同样要将其在答案中减去。那么就只要<strong>深搜扫一遍树，对于每个节点，算出祖先中距离自己大于当前二分值的祖先个数</strong>即可。至于如何快速计算这个数，用一个树状数组即可，下标存长度，不过数组开不下，那么就<strong>先把树扫一遍，记下每个长度，再将其离散化即可</strong>。</p>
<p>还有一个要注意的就是由于要二分答案，不能每次都把点分治的操作一模一样地做一遍，所以就把它给预处理出来，包括操作顺序，以及每个重心后的子树的重心等，还有每个点到重心的距离，存在两个vector里，这样就能直接访问了！</p>
<p>综合以上的思路，最终便能求解，复杂度约为<strong>nlog3n</strong>,代码有点长，要耐心打，<del>仔细调</del>！</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(int)l;i&lt;=(int)r;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(int)r;i&gt;=(int)l;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0;i&lt;(int)n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x)&amp;-(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50005</span>;</span><br><span class="line"><span class="type">int</span> n,m;ll k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">	<span class="type">int</span> tot,to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],len[N&lt;&lt;<span class="number">1</span>],head[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;tot++;to[tot]=y;len[tot]=z;nxt[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(head,<span class="number">-1</span>),tot=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EOR(i,x) for(int i=G.head[x];i!=-1;i=G.nxt[i])</span></span><br><span class="line">&#125;G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[N*<span class="number">10</span>],rt_v[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> RT,dfn,center,t_sz,sz[N],mx[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_center</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	sz[x]=<span class="number">1</span>,mx[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==f||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_center</span>(v,x);</span><br><span class="line">		sz[x]+=sz[v];</span><br><span class="line">		mx[x]=<span class="built_in">max</span>(mx[x],sz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	mx[x]=<span class="built_in">max</span>(mx[x],t_sz-sz[x]);</span><br><span class="line">	<span class="keyword">if</span>(!center||mx[center]&gt;mx[x])center=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_init</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">	v[dfn].<span class="built_in">push_back</span>(dis);</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==f||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dis_init</span>(v,x,dis+G.len[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">son_init</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">	dfn++;</span><br><span class="line">	<span class="built_in">dis_init</span>(x,f,dis);</span><br><span class="line">	<span class="built_in">sort</span>(v[dfn].<span class="built_in">begin</span>(),v[dfn].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_init</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">son_init</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">son_init</span>(v,x,G.len[i]);</span><br><span class="line">		center=<span class="number">0</span>,t_sz=sz[v];</span><br><span class="line">		<span class="built_in">get_center</span>(v,x);</span><br><span class="line">		rt_v[x].<span class="built_in">push_back</span>(center);</span><br><span class="line">		<span class="built_in">dfs_init</span>(center);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)rt_v[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">10</span>*n)v[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">mms</span>(vis,<span class="number">0</span>);</span><br><span class="line">	dfn=<span class="number">0</span>;</span><br><span class="line">	center=<span class="number">0</span>,t_sz=n;</span><br><span class="line">	<span class="built_in">get_center</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	RT=center;</span><br><span class="line">	<span class="built_in">dfs_init</span>(center);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id,sum,arr[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Binary_Indexed_Tree</span>&#123;</span><br><span class="line">	<span class="type">int</span> c[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span>&#123;<span class="keyword">while</span>(x&lt;=arr[<span class="number">0</span>])c[x]+=val,x+=<span class="built_in">lowbit</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="type">int</span> ret=<span class="number">0</span>;<span class="keyword">while</span>(x)&#123;ret+=c[x];x-=<span class="built_in">lowbit</span>(x);&#125;<span class="keyword">return</span> ret;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(c,<span class="number">0</span>);&#125;</span><br><span class="line">&#125;Tr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>,j=v[++id].<span class="built_in">size</span>()<span class="number">-1</span>,i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;v[id][i]+v[id][j]&lt;val)i++;</span><br><span class="line">		ret+=j-i,j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	sum+=<span class="built_in">calc</span>(val);</span><br><span class="line">	<span class="built_in">loop</span>(i,rt_v[x].<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> v=rt_v[x][i];</span><br><span class="line">		sum-=<span class="built_in">calc</span>(val);</span><br><span class="line">		<span class="built_in">dfs</span>(v,val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> dis,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	arr[++arr[<span class="number">0</span>]]=dis,arr[++arr[<span class="number">0</span>]]=dis-val;</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dis_dfs</span>(v,x,dis+G.len[i],val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> dis,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> pos1=<span class="built_in">lower_bound</span>(arr+<span class="number">1</span>,arr+arr[<span class="number">0</span>]+<span class="number">1</span>,dis)-arr;</span><br><span class="line">	<span class="type">int</span> pos2=<span class="built_in">lower_bound</span>(arr+<span class="number">1</span>,arr+arr[<span class="number">0</span>]+<span class="number">1</span>,dis-val)-arr;</span><br><span class="line">	sum-=Tr.<span class="built_in">sum</span>(pos2),Tr.<span class="built_in">update</span>(pos1,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">update_dfs</span>(v,x,dis+G.len[i],val);</span><br><span class="line">	&#125;</span><br><span class="line">	Tr.<span class="built_in">update</span>(pos1,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	sum=<span class="number">0</span>,<span class="built_in">dfs</span>(RT,x);</span><br><span class="line">	id=arr[<span class="number">0</span>]=<span class="number">0</span>,<span class="built_in">dis_dfs</span>(m,<span class="number">0</span>,<span class="number">0</span>,x);</span><br><span class="line">	<span class="built_in">sort</span>(arr+<span class="number">1</span>,arr+arr[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">	arr[<span class="number">0</span>]=<span class="built_in">unique</span>(arr+<span class="number">1</span>,arr+arr[<span class="number">0</span>]+<span class="number">1</span>)-arr<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">update_dfs</span>(m,<span class="number">0</span>,<span class="number">0</span>,x);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="type">int</span> Mx=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> x,y,z;</span><br><span class="line">			<span class="built_in">sf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			G.<span class="built_in">add</span>(x,y,z),G.<span class="built_in">add</span>(y,x,z);</span><br><span class="line">			Mx=<span class="built_in">max</span>(Mx,z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">tree_init</span>();</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=n*Mx,ans=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">			<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(mid)&gt;=k)ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans!=<span class="number">-1</span>)<span class="built_in">pf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Magic Tree（CF-1193B CEOI 2019 Day 2）</title>
    <url>/posts/4042.html</url>
    <content><![CDATA[<h1 id="magic-treecf-1193b-ceoi-2019-day-2">Magic Tree（CF-1193B CEOI
2019 Day 2）</h1>
<h2 id="题目描述">题目描述：</h2>
<p>给一个<span class="math inline">\(n\)</span>节点的树，其中有<span
class="math inline">\(m\)</span>个点有果实，分别在编号为<span
class="math inline">\(pi\)</span>的点上，在第<span
class="math inline">\(di\)</span>天成熟，在成熟的那天收割有<span
class="math inline">\(wi\)</span>的贡献。给出<span
class="math inline">\(K,di&lt;=K\)</span>.
通过断开树上的边来收割果实，每断开一个边，取不包含根的子树，获得上面所有成熟果实的贡献值，剩下的全部丢弃。每天都可以断任意条边。
问总共能收获到的最大贡献。 <span id="more"></span></p>
<h2 id="思路">思路：</h2>
<p>这题有一个比较重要的结论，就是<strong>在第<span
class="math inline">\(j\)</span>天割一条边<span
class="math inline">\([x,f]\)</span>时，如果<span
class="math inline">\(x\)</span>点为根的子树也有断掉的边时，那么这些边割掉的时间都必须小于等于<span
class="math inline">\(j\)</span></strong>，其实也算不上啥结论，想想就知道了。</p>
<h6 id="子任务1">子任务1</h6>
<p>有上面的结论就比较简单了，状压枚举哪些果实要获得贡献，然后<span
class="math inline">\(dfs\)</span>一遍判断时间上是否合法。
即如果有一个果实<span class="math inline">\(x\)</span>是<span
class="math inline">\(v\)</span>的祖先，且都被选，但<span
class="math inline">\(D[v]&gt;D[x]\)</span>就不合法了。代码比较简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mark[x]==ti)mxd[x]=D[x];</span><br><span class="line">	<span class="built_in">EOR</span>(G,i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">dfs</span>(v))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(mark[x]==ti&amp;&amp;D[x]&lt;mxd[v])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">chkmax</span>(mxd[x],mxd[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">loop</span>(i,<span class="number">1</span>&lt;&lt;m)&#123;</span><br><span class="line">		ti++;<span class="comment">//时间戳</span></span><br><span class="line">		ll sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">loop</span>(j,m)<span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">			mark[A[j+<span class="number">1</span>].p]=ti,sum+=A[j+<span class="number">1</span>].w;</span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">1</span>,n)mxd[j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">1</span>))<span class="built_in">chkmax</span>(ans,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="子任务2">子任务2</h6>
<p>没啥好说的，全加。</p>
<h6 id="子任务3">子任务3</h6>
<p>是一条链，且每个点贡献为<span
class="math inline">\(1\)</span>,相当于数个数。用上面的结论可知，其实就是从下到上<span
class="math inline">\(LIS\)</span>一下。</p>
<h6 id="子任务45">子任务4，5</h6>
<p>个人把两个合并起来了。。感觉分<span
class="math inline">\(K&lt;=2\)</span>没啥意义。。<br />
考虑<span class="math inline">\(f[n][k]\)</span>数组。<span
class="math inline">\(f[x][j]\)</span>表示在以<span
class="math inline">\(x\)</span>为根，前<span
class="math inline">\(j\)</span>天能收割到的最大值。
那么，我们有转移方程：</p>
<p><span class="math display">\[
f[x][j]=max((\sum f[v][D[x]])+W[x],\sum f[v][j]) (j&gt;=D[x])    
\]</span></p>
<p><span class="math display">\[
f[x][j]=\sum f[v][j](j&lt;D[x])
\]</span></p>
<p>应该不难理解，代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">EOR</span>(G,i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">0</span>,K)f[x][j]+=f[v][j];</span><br><span class="line">	&#125;</span><br><span class="line">	f[x][D[x]]+=W[x];</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,K)<span class="built_in">chkmax</span>(f[x][i],f[x][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">FOR</span>(j,<span class="number">0</span>,K)<span class="built_in">chkmax</span>(ans,f[<span class="number">1</span>][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="子任务678正解">子任务6,7,8（正解）</h6>
<p>这里可以在分点打（个人觉得没啥必要）。。
考虑原来的转移方程，其实每个<span
class="math inline">\(f[x]\)</span>最初都是一个后缀，然后每次还会将所有儿子的状态合并上来，显然想到线段树合并，每棵树维护一个点的装态，最后向上合并即可。</p>
<p>但是，还可以用启发式合并写，代码短且比较简练。 对每个节点开个<span
class="math inline">\(map\)</span>（<span class="math inline">\(set&lt;
pair &gt;\)</span>也行，随便）.表示每个点的<span
class="math inline">\(dp\)</span>状态，由于从子节点转移上来都是用加法所以直接循环合并加上来即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mp[x].<span class="built_in">size</span>()&lt;mp[v].<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">swap</span>(mp[x],mp[v]);</span><br><span class="line"><span class="keyword">for</span>(it=mp[v].<span class="built_in">begin</span>();it!=mp[v].<span class="built_in">end</span>();it++)</span><br><span class="line">    mp[x][(*it).X]+=(*it).Y;</span><br></pre></td></tr></table></figure>
<p>然后就是关键了，就是如何更新最大前缀。 还记得<span
class="math inline">\(\sum
f[v][D[x]]+W[x]\)</span>吗？这个值有可能更新掉<span
class="math inline">\(j&gt;=D[x]\)</span>的所有边，所以不仅仅是直接插入一个点那么简单了。我们把每个在它之后的点都扫一遍，如果当前点的w值大于插入值<span
class="math inline">\(val\)</span>，说明当前前缀更优，但由于<span
class="math inline">\(val\)</span>会影响所有在当前位置之后的前缀，所以要在当前位置上减掉。否则，就在<span
class="math inline">\(val\)</span>上减掉该值，并将枚举点删除。表示当前前缀被更新为新前缀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp[x][D[x]]+=W[x];<span class="comment">//加入一个新点（即一个新前缀）</span></span><br><span class="line">it=mp[x].<span class="built_in">upper_bound</span>(D[x]);</span><br><span class="line">ll val=W[x];<span class="comment">//表示新前缀最后一个点的值</span></span><br><span class="line"><span class="keyword">while</span>(it!=mp[x].<span class="built_in">end</span>())&#123;</span><br><span class="line">	ll w=it-&gt;Y;<span class="comment">//当前前缀的最后一个点值</span></span><br><span class="line">	<span class="keyword">if</span>(w&gt;=val)&#123;</span><br><span class="line">		it-&gt;Y-=val;<span class="comment">//使得当前前缀保持不变</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	val-=w;mp[x].<span class="built_in">erase</span>(it++);<span class="comment">//新前缀更优，删去原前缀的最后一个点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程一定要好好理解，这种用点维护前缀的思想很重要。 #### AC代码
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(l),i##R=(r);i&lt;=i##R;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(r),i##L=(l);i&gt;=i##L;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0,i##R=(n);i&lt;i##R;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chkmax</span><span class="params">(A &amp;x,<span class="type">const</span> B y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y)x=y;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chkmin</span><span class="params">(A &amp;x,<span class="type">const</span> B y)</span></span>&#123;<span class="keyword">if</span>(x&gt;y)x=y;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">	<span class="type">int</span> tot,to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],head[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;tot++;to[tot]=y;nxt[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(head,<span class="number">-1</span>);tot=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EOR(G,i,x) for(int i=G.head[x];i!=-1;i=G.nxt[i])</span></span><br><span class="line">&#125;G;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">	<span class="type">int</span> p,d,w;</span><br><span class="line">&#125;A[N];</span><br><span class="line"><span class="type">int</span> D[N],W[N];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;mp[N];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">EOR</span>(G,i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(mp[x].<span class="built_in">size</span>()&lt;mp[v].<span class="built_in">size</span>())<span class="built_in">swap</span>(mp[x],mp[v]);</span><br><span class="line">		<span class="keyword">for</span>(it=mp[v].<span class="built_in">begin</span>();it!=mp[v].<span class="built_in">end</span>();it++)mp[x][(*it).X]+=(*it).Y;</span><br><span class="line">	&#125;</span><br><span class="line">	mp[x][D[x]]+=W[x];</span><br><span class="line">	it=mp[x].<span class="built_in">upper_bound</span>(D[x]);</span><br><span class="line">	ll val=W[x];</span><br><span class="line">	<span class="keyword">while</span>(it!=mp[x].<span class="built_in">end</span>())&#123;</span><br><span class="line">		ll w=it-&gt;Y;</span><br><span class="line">		<span class="keyword">if</span>(w&gt;=val)&#123;</span><br><span class="line">			it-&gt;Y-=val;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		val-=w;mp[x].<span class="built_in">erase</span>(it++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;K);</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]);</span><br><span class="line">		G.<span class="built_in">add</span>(fa[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;A[i].p,&amp;A[i].d,&amp;A[i].w);</span><br><span class="line">		D[A[i].p]=A[i].d;</span><br><span class="line">		W[A[i].p]=A[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(it=mp[<span class="number">1</span>].<span class="built_in">begin</span>();it!=mp[<span class="number">1</span>].<span class="built_in">end</span>();it++)</span><br><span class="line">		ans+=it-&gt;Y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Subsequence Count（HDU-6155）</title>
    <url>/posts/42757.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>给出一个长度为n的01串S，有Q个操作：<br />
1. 翻转区间<span class="math inline">\([l,r]\)</span>（0变1,1变0）<br />
2. 求区间<span class="math inline">\([l,r]\)</span>有多少不同的子串</p>
<span id="more"></span>
<h2 id="思路">思路：</h2>
<p>看到这题：区间修改，区间询问，不难想到线段树，不过如何快速DP转移？</p>
<p>首先先考虑原本暴力DP的方法，<span
class="math inline">\(dp[x][flag]\)</span>为前<span
class="math inline">\(x\)</span>个数中以<span
class="math inline">\(1\)</span>或<span
class="math inline">\(0\)</span>结尾的子串有多少个。那么便有以下递推关系：</p>
<p><strong>若在第i位上的数字是f,那么</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][f]=dp[i-1][0]+dp[i-1][1]+1</span><br><span class="line"></span><br><span class="line">dp[i][!f]=dp[i-1][!f]</span><br></pre></td></tr></table></figure>
可以把关系式看成三部分：<strong>是否要加上一位的dp[0]，是否要加上一位的dp[1]，以及是否要加1.</strong></p>
<p>这样就可以用矩阵乘法转移了</p>
<p>若加入一个1，那么</p>
<p><span class="math inline">\(Matrix1=\)</span><br />
1,1,0<br />
0,1,0<br />
0,1,1<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(dp[i][0],dp[i][1],1)*Matrix1=(dp[i+1][0],dp[i+1][1],1)</span><br></pre></td></tr></table></figure></p>
<p>若加入一个0，那么</p>
<p><span class="math inline">\(Matrix0=\)</span><br />
1,0,0<br />
1,1,0<br />
1,0,1<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(dp[i][0],dp[i][1],1)*Matrix0=(dp[i+1][0],dp[i+1][1],1)</span><br></pre></td></tr></table></figure> 那么最终的答案应当就是(0,0,1)乘上若干个<span
class="math inline">\(Matrix1\)</span>和<span
class="math inline">\(Matrix0\)</span>.那么线段树预处理的便是<strong>区间的<span
class="math inline">\(Matrix0\)</span>或<span
class="math inline">\(Matrix1\)</span>的乘积</strong>了</p>
<p>最后需要的便是<span class="math inline">\(0\)</span>变<span
class="math inline">\(1\)</span>，<span
class="math inline">\(1\)</span>变<span
class="math inline">\(0\)</span>的操作了。这个不难，一个懒惰标记进行区间维护，每次把一个对于<span
class="math inline">\(1\)</span>（或<span
class="math inline">\(0\)</span>）的矩阵变成<span
class="math inline">\(0\)</span>（或<span
class="math inline">\(1\)</span>）的矩阵即可。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(int)l;i&lt;=(int)r;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(int)r;i&gt;=(int)l;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> type,l,r;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;<span class="comment">//矩阵 </span></span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="type">int</span> num[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(num,<span class="number">0</span>);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(num,<span class="number">0</span>);<span class="built_in">loop</span>(i,n)num[i][i]=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">make_sz</span><span class="params">(<span class="type">int</span> N,<span class="type">int</span> M)</span></span>&#123;n=N,m=M;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">loop</span>(i,n)<span class="built_in">loop</span>(j,m)<span class="built_in">pf</span>(<span class="string">&quot;%d%c&quot;</span>,num[i][j],j==m<span class="number">-1</span>?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">swap</span>(num[<span class="number">0</span>][<span class="number">0</span>],num[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(num[<span class="number">0</span>][<span class="number">1</span>],num[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(num[<span class="number">2</span>][<span class="number">0</span>],num[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> *(<span class="type">const</span> Matrix &amp;A)&#123;</span><br><span class="line">		Matrix ans;</span><br><span class="line">		ans.<span class="built_in">make_sz</span>(n,A.m);</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">loop</span>(i,A.n)<span class="built_in">loop</span>(j,A.m)</span><br><span class="line">			<span class="built_in">loop</span>(k,m)ans.num[i][j]=(ans.num[i][j]+<span class="number">1ll</span>*num[i][k]*A.num[k][j])%P;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S;</span><br><span class="line">Matrix M0=&#123;<span class="comment">//加入一个0时要乘的矩阵 </span></span><br><span class="line">	<span class="number">3</span>,<span class="number">3</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">Matrix M1=&#123;<span class="comment">//加入一个1时要乘的矩阵 </span></span><br><span class="line">	<span class="number">3</span>,<span class="number">3</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">YD_Tree</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="type">bool</span> lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	Matrix t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="comment">//向下更新需要&quot;翻转&quot;的区间 </span></span><br><span class="line">		<span class="keyword">if</span>(!lazy[p])<span class="keyword">return</span>;</span><br><span class="line">		lazy[ls]^=<span class="number">1</span>,lazy[rs]^=<span class="number">1</span>;</span><br><span class="line">		t[ls].<span class="built_in">flip</span>(),t[rs].<span class="built_in">flip</span>();</span><br><span class="line">		lazy[p]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="comment">//一个大区间的矩阵是左右两个矩阵的乘积 </span></span><br><span class="line">		t[p]=t[ls]*t[rs];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		lazy[p]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[l]==<span class="string">&#x27;1&#x27;</span>)t[p]=M1;</span><br><span class="line">			<span class="keyword">else</span> t[p]=M0;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">		<span class="built_in">build</span>(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">up</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">			lazy[p]^=<span class="number">1</span>;<span class="comment">//修改懒惰标记，注意是异或，不是直接等于1 </span></span><br><span class="line">			t[p].<span class="built_in">flip</span>();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">down</span>(p);</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)<span class="built_in">update</span>(rs,L,R,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="keyword">if</span>(mid&gt;=L)<span class="built_in">update</span>(ls,L,R,l,mid);</span><br><span class="line">		<span class="built_in">up</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Matrix <span class="title">Query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//区间询问 </span></span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)<span class="keyword">return</span> t[p];</span><br><span class="line">		<span class="built_in">down</span>(p);</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;=mid)<span class="keyword">return</span> <span class="built_in">Query</span>(ls,L,R,l,mid);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid)<span class="keyword">return</span> <span class="built_in">Query</span>(rs,L,R,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Query</span>(ls,L,R,l,mid)*<span class="built_in">Query</span>(rs,L,R,mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Tr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	S.<span class="built_in">make_sz</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">	S.num[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,S.num[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>,S.num[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//起始矩阵 </span></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">		Tr.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">			<span class="built_in">sf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;type,&amp;l,&amp;r);</span><br><span class="line">			<span class="keyword">if</span>(type==<span class="number">1</span>)Tr.<span class="built_in">update</span>(<span class="number">1</span>,l,r,<span class="number">1</span>,n);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				Matrix ret=S*Tr.<span class="built_in">Query</span>(<span class="number">1</span>,l,r,<span class="number">1</span>,n); </span><br><span class="line">				<span class="built_in">pf</span>(<span class="string">&quot;%d\n&quot;</span>,(ret.num[<span class="number">0</span>][<span class="number">0</span>]+ret.num[<span class="number">0</span>][<span class="number">1</span>])%P);<span class="comment">//注意不要把最后一位的常量加上 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Max Sum of Max-K-sub-sequence(HDU-3415)</title>
    <url>/posts/62718.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>Given a circle sequence A[1],A[2],A[3]……A[n]. Circle sequence means
the left neighbour of A[1] is A[n] , and the right neighbour of A[n] is
A[1]. Now your job is to calculate the max sum of a Max-K-sub-sequence.
Max-K-sub-sequence means a continuous non-empty sub-sequence which
length not exceed K.
给定一个环，A[1],A[2],A[3],…A[n],其中A[1]的左边是A[n].
求一个最大的连续和，长度不超过K。 <span id="more"></span></p>
<h2 id="输入">输入</h2>
<p>The first line of the input contains an integer T(1&lt;=T&lt;=100)
which means the number of test cases. Then T lines follow, each line
starts with two integers N , K(1&lt;=N&lt;=100000 , 1&lt;=K&lt;=N), then
N integers followed(all the integers are between -1000 and 1000).
第一行一个整数T，表示数据组数.不差过100
每组数据第一行两个整数N和K(1&lt;=N&lt;=100000 , 1&lt;=K&lt;=N)
接下来一行，n个整数[-1000,1000]</p>
<h2 id="输出">输出</h2>
<p>For each test case, you should output a line contains three integers,
the Max Sum in the sequence, the start position of the sub-sequence, the
end position of the sub-sequence. If there are more than one result,
output the minimum start position, if still more than one , output the
minimum length of
them.对于每组输出，满足条件的最大连续和以及起始位置和终止位置。
如果有多个结果，输出起始位置最小的，如果还是有多组结果，输出长度最短的。</p>
<h2 id="思路">思路：</h2>
<p>这题就是比较简单的单调队列应用，注意：<strong>以后队列的l,r初始化尽量把l定为0，r定为-1，避免不必要的错误产生</strong>。还有要注意的是，由于此题的单调性，不用考虑多种答案比较开头和长度的情况。接下来只要队列不写错就没什么问题了（这题要仔细掌握，巩固对单调队列的理解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="type">int</span> n,k,T,a[maxn],q[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">			a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;n+k;i++)a[i]=a[n]+a[i-n];</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> mx=<span class="number">-1e9</span>;</span><br><span class="line">		<span class="type">int</span> ll,rr;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;a[i<span class="number">-1</span>]&lt;a[q[r<span class="number">-1</span>]])r--;</span><br><span class="line">			q[r++]=i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-q[l]&gt;k)l++;</span><br><span class="line">			<span class="keyword">if</span>(mx&lt;a[i]-a[q[l]])&#123;</span><br><span class="line">				mx=a[i]-a[q[l]];</span><br><span class="line">				ll=q[l]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;n)</span><br><span class="line">					rr=i%n;</span><br><span class="line">				<span class="keyword">else</span> rr=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,mx,ll,rr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>TheProduct（Topcoder 10421）</title>
    <url>/posts/12133.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>给你一个数列，<span class="math inline">\(k\)</span>，<span
class="math inline">\(maxDist\)</span>，要你从数列中选出k个数，按照原来的先后顺序排成一个新的数列，要求：新的数列中的每对相邻的数在原数列中的距离不超过<span
class="math inline">\(maxDist\)</span>。求满足条件的数列中，k个元素乘积的最大值。
<span id="more"></span> ## 输入 保证数列元素个数不超过<span
class="math inline">\(50\)</span>个。<br />
每个元素在<span class="math inline">\([-50,50]\)</span>的范围内。<br />
<span
class="math inline">\(k\)</span>在[1,min(10,数列个数)]的范围内。<br />
<span class="math inline">\(maxDist\)</span>在<span
class="math inline">\([1,50]\)</span>的范围内。</p>
<h2 id="输出">输出</h2>
<p>输出最大的乘积</p>
<h2 id="思路">思路：</h2>
<p>比较简单的线型动态规划，只要细心些，注意小细节，范围不要搞错剩下的都比较简单。</p>
<h4 id="状态定义">状态定义</h4>
<p>定义<span
class="math inline">\(dp[i][j]\)</span>为取了<strong>i</strong>个数字，最后一取的数字的位置为<strong>j</strong>的最大乘积值。<br />
<strong>不过这时要注意，由于元素有可能是负数，所以需要从乘积的最小值转移才能达到最大，所以要再开一个数组mn[][]，来记录最小值，其他定义均与dp数组相同</strong></p>
<h4 id="状态转移">状态转移</h4>
<p>转移唯一需要注意的就是范围(其实也可以不注意范围，每次循环完把该清空的地方清空就行了)。<br />
最初把取第一个数的情况赋上(即<span
class="math inline">\(dp(mn)[1][1..n]\)</span>),然后每次的状态从<span
class="math inline">\(dp[j-1][min(1,i-maxDist)......i-1]\)</span>转移得到，至于j的范围，便是<span
class="math inline">\([2,min(k,i)]\)</span>.<br />
转移完后最终的答案便是<span
class="math inline">\(max(dp[k][k...n],mn[k][k...n])\)</span></p>
<p>总体来说还是比较简单的，一般状态好想到的DP都不难。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(int)l;i&lt;=(int)r;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(int)r;i&gt;=(int)l;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0;i&lt;(int)n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 55</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> num[N],k,maxDist;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;numbers;</span><br><span class="line">ll dp[<span class="number">15</span>][N];<span class="comment">//取j个,最后一个的位置为k </span></span><br><span class="line">ll mn[<span class="number">15</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y)x=y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;<span class="keyword">if</span>(x&gt;y)x=y;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TheProduct</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;numbers,<span class="type">int</span> k,<span class="type">int</span> maxDist)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">mms</span>(dp,<span class="number">-63</span>);</span><br><span class="line">		<span class="built_in">mms</span>(mn,<span class="number">63</span>);</span><br><span class="line">		ll MIN=dp[<span class="number">0</span>][<span class="number">0</span>],MAX=mn[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> n=numbers.<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">//预处理 </span></span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)dp[<span class="number">1</span>][i]=mn[<span class="number">1</span>][i]=numbers[i<span class="number">-1</span>];<span class="comment">//取一个数的情况 </span></span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">			<span class="built_in">FOR</span>(j,<span class="number">2</span>,<span class="built_in">min</span>(k,i))&#123;<span class="comment">//枚举取数的个数 </span></span><br><span class="line">				<span class="built_in">FOR</span>(l,<span class="built_in">max</span>(<span class="number">1</span>,i-maxDist),i<span class="number">-1</span>)&#123;<span class="comment">//枚举上一个数的位置 </span></span><br><span class="line">					ll lmx=dp[j<span class="number">-1</span>][l];</span><br><span class="line">					ll lmn=mn[j<span class="number">-1</span>][l];</span><br><span class="line">					ll num=numbers[i<span class="number">-1</span>];</span><br><span class="line">					<span class="keyword">if</span>(lmx!=MIN)<span class="built_in">Max</span>(dp[j][i],lmx*num),<span class="built_in">Min</span>(mn[j][i],lmx*num); </span><br><span class="line">					<span class="keyword">if</span>(lmn!=MAX)<span class="built_in">Max</span>(dp[j][i],lmn*num),<span class="built_in">Min</span>(mn[j][i],lmn*num);</span><br><span class="line">					<span class="comment">//dp为最大值，mn为最小值 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=MIN;</span><br><span class="line">		<span class="built_in">FOR</span>(i,k,n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[k][i]!=MIN)<span class="built_in">Max</span>(ans,dp[k][i]);</span><br><span class="line">			<span class="keyword">if</span>(mn[k][i]!=MAX)<span class="built_in">Max</span>(ans,mn[k][i]);</span><br><span class="line">			<span class="comment">//寻找答案 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Query on a tree V（SPOJ - QTREE5）</title>
    <url>/posts/59843.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>You are given a tree (an acyclic undirected connected graph) with N
nodes. The tree nodes are numbered from 1 to N. We define dist(a, b) as
the number of edges on the path from node a to node b.</p>
<p>Each node has a color, white or black. All the nodes are black
initially.</p>
<p>We will ask you to perfrom some instructions of the following
form:</p>
<ul>
<li>0 i : change the color of i-th node(from black to white, or from
white to black).</li>
<li>1 v : ask for the minimum dist(u, v), node u must be white(u can be
equal to v). Obviously, as long as node v is white, the result will
always be 0.</li>
</ul>
<p>给出一棵n结点的树，边权为1，一开始每个点颜色都是黑色。
现有q个询问，每次询问会有两种操作： 1.0 i 改变i的颜色，黑变白，白变黑。
2.1 v 询问与v距离最近的白点，显然，当v颜色为白色时，答案是0。
<span id="more"></span></p>
<h2 id="输入">输入</h2>
<ul>
<li>In the first line there is an integer N (N &lt;= 100000)</li>
<li>In the next N-1 lines, the i-th line describes the i-th edge: a line
with two integers a b denotes an edge between a and b.</li>
<li>In the next line, there is an integer Q denotes the number of
instructions (Q &lt;= 100000)</li>
<li>In the next Q lines, each line contains an instruction “0 i” or “1
v”</li>
</ul>
<h2 id="输出">输出</h2>
<p>For each “1 v” operation, print one integer representing its result.
If there is no white node in the tree, you should write “-1”.</p>
<h2 id="思路">思路：</h2>
<p>这是自己写的第一个动态点分治题。</p>
<blockquote>
<p>堆</p>
</blockquote>
<p><strong>在每个点上都建立一个可删除堆</strong>（手写也可以，像我一样偷懒的话两个系统堆模拟也行，一个记录队列中加入的，一个记录堆中被删除的元素，每次遇到队首相同的元素，就同时弹出即可！）这样每个点都可以（近乎）<span
class="math inline">\(O(1)\)</span>的求出一个点上的答案，不过这样的话，更新的复杂度会直接爆炸！</p>
<blockquote>
<p>点分治</p>
</blockquote>
<p>动态点分治的用处这时就体现出来了，就只用<strong>更新点分治树树根到该点的路径上的所有点</strong>即可，复杂度为<span
class="math inline">\(O(logn)\)</span>，然后在询问的时候，同理在这条路径上，枚举每一个点，将<strong>该点队列上的最大值再加上该点到询问点上的距离的值求出</strong>，一路<span
class="math inline">\(min\)</span>上去最后得到的就是答案，复杂度同样为<span
class="math inline">\(O(logn)\)</span>，枚举该路径只要从当前点开始在点分治树上跳父亲即可</p>
<p>最后就是求两点之间的路径长度，应该不难，用<span
class="math inline">\(LCA\)</span>法即可，<span
class="math inline">\(lca\)</span>可以直接预处理，用跳重链法等都可以，有
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dis(x,y)=dep[x]+dep[y]-dep[lca]*2</span><br></pre></td></tr></table></figure> <span class="math inline">\(dep\)</span>为该点深度。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=l,END=r;i&lt;=END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=r,END=l;i&gt;=END;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0,END=n;i&lt;END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;<span class="comment">//正向表 </span></span><br><span class="line">	<span class="type">int</span> tot,to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],head[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;tot++;to[tot]=y;nxt[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(head,<span class="number">-1</span>);tot=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EOR(i,x) for(int i=G.head[x];i!=-1;i=G.nxt[i])</span></span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Distance_Calculator</span>&#123;<span class="comment">//计算两点的路径 </span></span><br><span class="line">	<span class="type">int</span> sz[N],son[N],fa[N],dep[N],top[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">		fa[x]=f,dep[x]=dep[f]+<span class="number">1</span>;</span><br><span class="line">		sz[x]=<span class="number">1</span>,son[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">			<span class="type">int</span> v=G.to[i];</span><br><span class="line">			<span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(v,x);</span><br><span class="line">			sz[x]+=sz[v];</span><br><span class="line">			<span class="keyword">if</span>(sz[son[x]]&lt;sz[v])son[x]=v;</span><br><span class="line"><span class="comment">//			pf(&quot;x:%d son[x]:%d\n&quot;,x,son[x]);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">top_dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line"><span class="comment">//		pf(&quot;x:%d f:%d tp:%d son[x]:%d\n&quot;,x,f,tp,son[x]);</span></span><br><span class="line">		top[x]=tp;</span><br><span class="line">		<span class="keyword">if</span>(son[x])<span class="built_in">top_dfs</span>(son[x],x,tp);</span><br><span class="line">		<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">			<span class="type">int</span> v=G.to[i];</span><br><span class="line">			<span class="keyword">if</span>(v==f||v==son[x])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">top_dfs</span>(v,x,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//跳重链 </span></span><br><span class="line">		<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])x=fa[top[x]];</span><br><span class="line">			<span class="keyword">else</span> y=fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[y]&gt;dep[x]?x:y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> dep[x]+dep[y]-(dep[<span class="built_in">LCA</span>(x,y)]&lt;&lt;<span class="number">1</span>);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">top_dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&#123;<span class="comment">//可删除堆 </span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;Q,del;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;del.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(!del.<span class="built_in">empty</span>()&amp;&amp;del.<span class="built_in">top</span>()==Q.<span class="built_in">top</span>())Q.<span class="built_in">pop</span>(),del.<span class="built_in">pop</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;Q.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>&#123;<span class="built_in">Erase</span>();<span class="keyword">return</span> Q.<span class="built_in">empty</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;<span class="built_in">Erase</span>();<span class="keyword">if</span>(<span class="built_in">Empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;<span class="keyword">else</span> <span class="keyword">return</span> Q.<span class="built_in">top</span>();&#125;</span><br><span class="line">	</span><br><span class="line">&#125;H[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> sz[N],mx[N],center,t_sz;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_center</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f)</span></span>&#123;<span class="comment">//找重心 </span></span><br><span class="line">	sz[x]=<span class="number">1</span>,mx[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==f||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_center</span>(v,x);</span><br><span class="line">		sz[x]+=sz[v];</span><br><span class="line">		mx[x]=<span class="built_in">max</span>(mx[x],sz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	mx[x]=<span class="built_in">max</span>(mx[x],t_sz-sz[x]);</span><br><span class="line">	<span class="keyword">if</span>(!center||mx[center]&gt;mx[x])center=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//预处理点分树 </span></span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">EOR</span>(i,x)&#123;</span><br><span class="line">		<span class="type">int</span> v=G.to[i];</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		t_sz=sz[v],center=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">get_center</span>(v,x);</span><br><span class="line">		fa[center]=x;<span class="comment">//关键 </span></span><br><span class="line">		<span class="built_in">DAC</span>(center);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> col[N];<span class="comment">//记录颜色 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	H[x].<span class="built_in">Push</span>(<span class="number">0</span>);<span class="comment">//加入自己本身 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=fa[x];i;i=fa[i])&#123;<span class="comment">//暴跳父亲，更新 </span></span><br><span class="line">		<span class="type">int</span> dis=D.<span class="built_in">dist</span>(x,i);</span><br><span class="line">		H[i].<span class="built_in">Push</span>(dis);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	H[x].<span class="built_in">Del</span>(<span class="number">0</span>);<span class="comment">//删除自己本身 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=fa[x];i;i=fa[i])&#123;<span class="comment">//暴跳父亲，删除 </span></span><br><span class="line">		<span class="type">int</span> dis=D.<span class="built_in">dist</span>(x,i);</span><br><span class="line">		H[i].<span class="built_in">Del</span>(dis);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//询问 </span></span><br><span class="line">	<span class="type">int</span> ret=<span class="number">2e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i;i=fa[i])&#123;</span><br><span class="line">		<span class="type">int</span> dis=D.<span class="built_in">dist</span>(x,i);</span><br><span class="line">		<span class="type">int</span> dis2=H[i].<span class="built_in">Top</span>();</span><br><span class="line">		<span class="keyword">if</span>(dis2==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">		ret=<span class="built_in">min</span>(ret,dis2+dis);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret==<span class="number">2e9</span>?<span class="number">-1</span>:ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		G.<span class="built_in">add</span>(x,y);</span><br><span class="line">		G.<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	t_sz=n,<span class="built_in">get_center</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">DAC</span>(center);</span><br><span class="line">	D.<span class="built_in">init</span>();</span><br><span class="line">	<span class="comment">//以上为预处理 </span></span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="type">int</span> op,v;</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;v);</span><br><span class="line">		<span class="keyword">if</span>(!op)&#123;</span><br><span class="line">			col[v]^=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(col[v])<span class="built_in">insert</span>(v);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">erase</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">pf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Query</span>(v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Query on a tree IV(SPOJ - QTREE4)</title>
    <url>/posts/59900.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>You are given a tree (an acyclic undirected connected graph) with N
nodes, and nodes numbered 1,2,3…,N. Each edge has an integer value
assigned to it(note that the value can be negative). Each node has a
color, white or black. We define dist(a, b) as the sum of the value of
the edges on the path from node a to node b.</p>
<p>All the nodes are white initially.</p>
<p>We will ask you to perfrom some instructions of the following
form:</p>
<ul>
<li><strong>C a</strong> : change the color of node a.(from black to
white or from white to black)</li>
<li><strong>A</strong> : ask for the maximum dist(a, b), both of node a
and node b must be white(a can be equal to b). Obviously, as long as
there is a white node, the result will alway be non negative.</li>
</ul>
<p>给出一棵n个结点的树，每条边有边权。一开始，每个点都是白色的。
再给出q个询问，每次询问有两种操作：</p>
<p>1.C a 表示改变a结点的颜色，黑变白，白变黑。<br />
2.A 表示询问树上某两个白点（可以是同一个点）间最远距离
注意原题卡常，可以尝试换用clang编译器提交。 <span id="more"></span></p>
<h2 id="思路">思路：</h2>
<blockquote>
<p>QTree 5 的进化版。。（为甚是这个顺序我也不清楚。。）</p>
</blockquote>
<p>主要操作和QTree4的操作差不多，详细内容可见那题题解：<a
href="https://www.cnblogs.com/Heinz/p/10464218.html/">Query on a tree
V</a></p>
<p>上一题的思想是<strong>在每个点开一个可删堆<span
class="math inline">\(Q1\)</span>，然后利用点分树优化查询与更新</strong>，这次其实也差不多只不过它并没有给你确定其中一个点，那么接下来的操作就比较<del>骚</del>有趣了</p>
<p>为了避免多次枚举，我们在每个点上多开一个队列<span
class="math inline">\(Q2\)</span>，存的内容是<strong>距离每个儿子上最远的点到自身的距离</strong>，听起来有些绕，好好理解一下。。然后每次更新时，只要注意当前的儿子的最远距离（记录在原先的那个队列中）——也就是<span
class="math inline">\(Q1\)</span>的<span
class="math inline">\(Top\)</span>被更新掉时，就要对应的去更新它父亲的<span
class="math inline">\(Q2\)</span>，注意要算上儿子到父亲的距离，为了方便，我的<span
class="math inline">\(Q1\)</span>中存的值就是算上它到父亲的距离的。那么若要找经过该点的最大距离时，就只用<strong>在它所对应的<span
class="math inline">\(Q2\)</span>中找出最大的两个值的和即可（注意如果只有一个值的时候，要返回0，因为题意说明可以是同一个点也算）</strong>。</p>
<p>所以代码中最关键的两点就是对于这三种队列的更新了！仔细理解。</p>
<p>最后就是把每个点的最大值存在最后一个队列<span
class="math inline">\(A\)</span>中，同理<strong>每次一个点的<span
class="math inline">\(Q2\)</span>中的最大两值和改变时，都要在<span
class="math inline">\(A\)</span>中进行对应的更新(删除旧值，加入新值)</strong>，那么最终查询答案只要返回<span
class="math inline">\(A\)</span>的<span
class="math inline">\(Top\)</span>即可，至于没有白点的判断，只要维护一个<span
class="math inline">\(tot\)</span>，计数白点数量，不必多说！</p>
<p>还有一个需要说的就是点分树的存法，由于这题时限，不能用常规<span
class="math inline">\(log\)</span>求<span
class="math inline">\(LCA\)</span>来算距离，可以<strong>全部预处理出来存一个正向表（或<span
class="math inline">\(vector\)</span>）中</strong>。存每个儿子的每个父亲以及距离，这些均可以在一个<span
class="math inline">\(dfs\)</span>中求出</p>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(register int i=l,END=r;i&lt;=END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(register int i=r,END=l;i&gt;=END;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(register int i=0,END=n;i&lt;END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">	<span class="type">int</span> tot,to[N*<span class="number">20</span>],nxt[N*<span class="number">20</span>],len[N*<span class="number">20</span>],head[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;tot++;to[tot]=y;nxt[tot]=head[x];len[tot]=z;head[x]=tot;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">mms</span>(head,<span class="number">-1</span>);tot=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EOR(A,i,x) for(register int i=A.head[x];i!=-1;i=A.nxt[i])</span></span><br><span class="line">&#125;G,G2;<span class="comment">//原树和点分树的路径 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&#123;<span class="comment">//可删堆 </span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt;Q,del;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">if</span>(x!=-INF)Q.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">if</span>(x!=-INF)del.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(!del.<span class="built_in">empty</span>()&amp;&amp;Q.<span class="built_in">top</span>()==del.<span class="built_in">top</span>())Q.<span class="built_in">pop</span>(),del.<span class="built_in">pop</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Q.<span class="built_in">size</span>()-del.<span class="built_in">size</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;<span class="built_in">upd</span>();<span class="keyword">if</span>(Q.<span class="built_in">empty</span>())<span class="keyword">return</span> -INF;<span class="keyword">return</span> Q.<span class="built_in">top</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Sum2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">upd</span>();<span class="type">int</span> siz=<span class="built_in">Size</span>();</span><br><span class="line">		<span class="keyword">if</span>(!siz)<span class="keyword">return</span> -INF;</span><br><span class="line">		<span class="keyword">if</span>(siz==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> mx1=<span class="built_in">Top</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> mx2=<span class="built_in">Top</span>();Q.<span class="built_in">push</span>(mx1);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(mx1+mx2,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;A,B[N],C[N];<span class="comment">//C便是题解中的Q1,B便是题解中的Q2</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> col[N];<span class="comment">//记录颜色 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DAC_Tree</span>&#123;<span class="comment">//点分树 </span></span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="type">int</span> sz[N],mx[N],fa[N];</span><br><span class="line">	<span class="type">int</span> t_sz,center;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> dis,<span class="type">int</span> center)</span></span>&#123;<span class="comment">//预处理上面的G2 </span></span><br><span class="line">		G2.<span class="built_in">add</span>(x,center,dis);</span><br><span class="line">		<span class="built_in">EOR</span>(G,i,x)&#123;</span><br><span class="line">			<span class="type">int</span> v=G.to[i];</span><br><span class="line">			<span class="keyword">if</span>(v==f||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">get_dis</span>(v,x,dis+G.len[i],center);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_center</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f)</span></span>&#123;<span class="comment">//寻找重心 </span></span><br><span class="line">		sz[x]=<span class="number">1</span>,mx[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">EOR</span>(G,i,x)&#123;</span><br><span class="line">			<span class="type">int</span> v=G.to[i];</span><br><span class="line">			<span class="keyword">if</span>(v==f||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">get_center</span>(v,x);</span><br><span class="line">			sz[x]+=sz[v];</span><br><span class="line">			mx[x]=<span class="built_in">max</span>(mx[x],sz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		mx[x]=<span class="built_in">max</span>(mx[x],t_sz-sz[x]);</span><br><span class="line">		<span class="keyword">if</span>(!center||mx[center]&gt;mx[x])center=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DAC</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//点分治 </span></span><br><span class="line">		vis[x]=<span class="number">1</span>;</span><br><span class="line">		G2.<span class="built_in">add</span>(x,x,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">EOR</span>(G,i,x)&#123;</span><br><span class="line">			<span class="type">int</span> v=G.to[i];</span><br><span class="line">			<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">get_dis</span>(v,x,G.len[i],x);</span><br><span class="line">			center=<span class="number">0</span>,t_sz=sz[v];</span><br><span class="line">			<span class="built_in">get_center</span>(v,x);</span><br><span class="line">			fa[center]=x;</span><br><span class="line">			<span class="built_in">DAC</span>(center);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//以下两个函数为本题关键，注意三个队列的更新 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//把一个点变白 </span></span><br><span class="line">		<span class="type">int</span> sum=B[x].<span class="built_in">Sum2</span>();</span><br><span class="line">		B[x].<span class="built_in">Push</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> nsum=B[x].<span class="built_in">Sum2</span>();</span><br><span class="line">		<span class="keyword">if</span>(nsum!=sum)&#123;</span><br><span class="line">			A.<span class="built_in">Del</span>(sum);</span><br><span class="line">			A.<span class="built_in">Push</span>(nsum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">EOR</span>(G2,i,x)&#123;</span><br><span class="line">			<span class="keyword">if</span>(G2.nxt[i]==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> v=G2.to[i],f=G2.to[G2.nxt[i]],dis=G2.len[G2.nxt[i]],tp=C[v].<span class="built_in">Top</span>();</span><br><span class="line">			C[v].<span class="built_in">Push</span>(dis);</span><br><span class="line">			<span class="type">int</span> ntp=C[v].<span class="built_in">Top</span>();</span><br><span class="line">			<span class="keyword">if</span>(ntp!=tp)&#123;</span><br><span class="line">				sum=B[f].<span class="built_in">Sum2</span>();</span><br><span class="line">				B[f].<span class="built_in">Del</span>(tp);</span><br><span class="line">				B[f].<span class="built_in">Push</span>(dis);</span><br><span class="line">				nsum=B[f].<span class="built_in">Sum2</span>();</span><br><span class="line">				<span class="keyword">if</span>(nsum!=sum)&#123;</span><br><span class="line">					A.<span class="built_in">Del</span>(sum);</span><br><span class="line">					A.<span class="built_in">Push</span>(nsum);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//把一个点变黑 </span></span><br><span class="line">		<span class="type">int</span> sum=B[x].<span class="built_in">Sum2</span>();</span><br><span class="line">		B[x].<span class="built_in">Del</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> nsum=B[x].<span class="built_in">Sum2</span>();</span><br><span class="line">		<span class="keyword">if</span>(nsum!=sum)&#123;</span><br><span class="line">			A.<span class="built_in">Del</span>(sum);</span><br><span class="line">			A.<span class="built_in">Push</span>(nsum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">EOR</span>(G2,i,x)&#123;</span><br><span class="line">			<span class="keyword">if</span>(G2.nxt[i]==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> v=G2.to[i],dis=G2.len[G2.nxt[i]],f=G2.to[G2.nxt[i]],tp=C[v].<span class="built_in">Top</span>();</span><br><span class="line">			C[v].<span class="built_in">Del</span>(dis);</span><br><span class="line">			<span class="type">int</span> ntp=C[v].<span class="built_in">Top</span>();</span><br><span class="line">			<span class="keyword">if</span>(ntp!=tp)&#123;</span><br><span class="line">				sum=B[f].<span class="built_in">Sum2</span>();</span><br><span class="line">				<span class="keyword">if</span>(tp!=-INF)B[f].<span class="built_in">Del</span>(tp);</span><br><span class="line">				B[f].<span class="built_in">Push</span>(C[v].<span class="built_in">Top</span>());</span><br><span class="line">				nsum=B[f].<span class="built_in">Sum2</span>();</span><br><span class="line">				<span class="keyword">if</span>(nsum!=sum)&#123;</span><br><span class="line">					A.<span class="built_in">Del</span>(sum);</span><br><span class="line">					A.<span class="built_in">Push</span>(nsum);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//预处理 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		center=<span class="number">0</span>,t_sz=n;</span><br><span class="line">		<span class="built_in">get_center</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">DAC</span>(center);</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Tr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">clear</span>(),G2.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">loop</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		G.<span class="built_in">add</span>(x,y,z),G.<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	Tr.<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> q;tot=n;</span><br><span class="line">	<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">		<span class="built_in">sf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tot)<span class="built_in">pf</span>(<span class="string">&quot;They have disappeared.\n&quot;</span>);<span class="comment">//无白点 </span></span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">pf</span>(<span class="string">&quot;%d\n&quot;</span>,A.<span class="built_in">Top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="type">int</span> a;<span class="built_in">sf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a); </span><br><span class="line">			col[a]^=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(col[a])&#123;Tr.<span class="built_in">erase</span>(a);tot--;&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;Tr.<span class="built_in">insert</span>(a);tot++;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>SameDigits（Topcoder 7705）</title>
    <url>/posts/53875.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>令函数<strong>f(x)</strong>(<strong>x</strong>为正整数)，返回值为<strong>x</strong>的<strong>位数中的最长连续相同的数字长度</strong>，比如<strong>f(344488)=3,f(123)=1</strong>.
现在给你两个正整数<strong>n</strong>与<strong>k</strong>,
要求计算出有多少个位数不大于<strong>n</strong>的数<strong>x</strong>满足<strong>f(x)=k.</strong>
返回的答案向<strong>44444444</strong>取模</p>
<span id="more"></span>
<h2 id="输入">输入</h2>
<p>两个正整数<strong>n</strong>,<strong>k</strong>.
<strong>n,k≤1000</strong></p>
<h2 id="输出">输出</h2>
<p>输出答案</p>
<h2 id="思路">思路：</h2>
<p>比较有趣的一道DP题，对于状态的定义比较困难，若能想到定义方式，那么状态转移比较简单了。</p>
<p>自己当初就是状态定义的太差导致想了很久。。</p>
<h4 id="状态定义">状态定义</h4>
<p>定义<strong>DP[i][j][flag]</strong>为<strong>还需要填i个数，已填了的数中结尾有j个连续相同的数，是否已出现过k个连续相同的数了，有多少种填发。</strong>
由此可知，答案便<strong>是9×(dp[k-1][1][0]+..+dp[n-1][1][0]</strong>
(其实就是填了第一个数有九种方案，剩下的数有 <strong>dp [i-1] [1]
[0]</strong> 种方法)</p>
<h4 id="状态转移">状态转移</h4>
<p>接下来就是状态转移了，其实状态知道了后转移就不难了，最初<strong>dp
[0] [k] [0] ,dp [0] [1..k] [1]</strong>
的值都为1（整个数都填完了，只需考虑它符不符合条件），然后<strong>每次删掉最后一个数，枚举最后连续长度l，若是小于k的那么就从l+1和1中转移(1说明与前面的数不同，连续长度变回1),若刚好等于k，那么只能从1中转移，因为连续长度不能超过k</strong>，此时的flag注意要是1，因为已经达到一次k的长度了！</p>
<p>这样这题就做完了，看似十分简单，但要想到这样写个人认为是很困难的，要仔细揣摩揣摩。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(int)l;i&lt;=(int)r;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(int)r;i&gt;=(int)l;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0;i&lt;(int)n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P 44444444</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> K;</span><br><span class="line">ll dp[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SameDigits</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">howMany</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">		K=k;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">mms</span>(dp,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">			dp[<span class="number">0</span>][i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">			dp[<span class="number">0</span>][i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[<span class="number">0</span>][k][<span class="number">1</span>]=dp[<span class="number">0</span>][k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//仍需要填几个数 </span></span><br><span class="line">			<span class="built_in">FOR</span>(j,<span class="number">1</span>,k<span class="number">-1</span>)&#123;<span class="comment">//已填的数中的最后有多少个相同的数 </span></span><br><span class="line">				dp[i][j][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][j+<span class="number">1</span>][<span class="number">1</span>]+<span class="number">9</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>])%P;</span><br><span class="line">				dp[i][j][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j+<span class="number">1</span>][<span class="number">0</span>]+<span class="number">9</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])%P;</span><br><span class="line">				<span class="comment">//若没有达到k个，那么有两种情况：与最后一个相同(j变为j+1)，或者不同(j变为1)</span></span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][k][<span class="number">1</span>]=dp[i][k][<span class="number">0</span>]=<span class="number">9</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>]%P;</span><br><span class="line">			<span class="comment">//当达到k个时,下一个的j必须是1，flag变为1表示已经达到过k了！</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">FOR</span>(i,k,n)ans=(ans+<span class="number">9</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])%P;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，这题不用循环DP，用递归也可以，两份我都写了一遍这里也把代码上一
下，思路几乎一样，就是逆过来想，另外就是运行速度会慢些，因为要递归。。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define FOR(i,l,r) for(int i=(int)l;i&lt;=(int)r;i++)</span><br><span class="line">#define DOR(i,r,l) for(int i=(int)r;i&gt;=(int)l;i--)</span><br><span class="line">#define loop(i,n) for(int i=0;i&lt;(int)n;i++)</span><br><span class="line">#define mms(a,x) memset(a,x,sizeof a)</span><br><span class="line">#define sf scanf</span><br><span class="line">#define pf printf</span><br><span class="line">#define N 1005</span><br><span class="line">#define P 44444444</span><br><span class="line">typedef vector&lt;int&gt; vi;</span><br><span class="line">typedef vector&lt;string&gt; vs;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef double db;</span><br><span class="line">typedef long double ldb;</span><br><span class="line">typedef pair&lt;int,int&gt;pii;</span><br><span class="line">typedef vector&lt;pii&gt; vpii;</span><br><span class="line">const int inf=0x20202020;</span><br><span class="line">const ll mod=1000000007;</span><br><span class="line">const db eps=1e-9;</span><br><span class="line">const db pi=3.1415926535897932384626;</span><br><span class="line">ll powmod(ll a,ll b)&#123;ll res=1;a%=mod;for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</span><br><span class="line">int K;</span><br><span class="line">ll dp[N][N][2];</span><br><span class="line">ll f(int n,int lst,bool flag)&#123;</span><br><span class="line">	if(dp[n][lst][flag]!=-1)return dp[n][lst][flag];</span><br><span class="line">	if(!n)&#123;</span><br><span class="line">		if(flag||lst==K)return dp[n][lst][flag]=1;</span><br><span class="line">		else return dp[n][lst][flag]=0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(lst==K)return dp[n][lst][flag]=9*f(n-1,1,1)%P;</span><br><span class="line">	return dp[n][lst][flag]=(f(n-1,lst+1,flag)+9*f(n-1,1,flag))%P;</span><br><span class="line">&#125;</span><br><span class="line">int howMany(int n,int k)&#123;</span><br><span class="line">	K=k;</span><br><span class="line">	ll ans=0;</span><br><span class="line">	mms(dp,-1);</span><br><span class="line">	FOR(i,k,n)ans=(ans+9*f(i-1,1,0))%P;</span><br><span class="line">	return (int)ans;</span><br><span class="line">&#125;</span><br><span class="line">class SameDigits &#123;</span><br><span class="line">public:</span><br><span class="line">	int howMany(int n, int k) &#123;</span><br><span class="line">		K=k;</span><br><span class="line">		ll ans=0;</span><br><span class="line">		mms(dp,-1);</span><br><span class="line">		FOR(i,k,n)ans=(ans+9*f(i-1,1,0))%P;</span><br><span class="line">		return (int)ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>俄罗斯套娃（JOISC 2016 Day 1）</title>
    <url>/posts/16994.html</url>
    <content><![CDATA[<h1 id="俄罗斯套娃joisc-2016-day-1">俄罗斯套娃（JOISC 2016 Day 1）</h1>
<h2 id="题目描述">题目描述</h2>
<p>你开了一家卖俄罗斯套娃的店。因此，你向厂家订购了 <span
class="math inline">\(N\)</span>个俄罗斯套娃，这些娃娃被编号为 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(N\)</span>，其中第 <span
class="math inline">\(i\)</span> 个套娃是一个的直径为 <span
class="math inline">\(R_i\)</span> 高度为 <span
class="math inline">\(H_i\)</span> 的直♂柱体
。每个俄罗斯套娃都只能套高和直径严格比他小的套娃。同时只要满足条件，俄罗斯套娃可以嵌套多次。</p>
<p>有一天，你收到了厂家的来电，告诉你你预定的 <span
class="math inline">\(N\)</span>
个娃娃不能一次性全部做完。所以第一批只会送达直径大于等于 <span
class="math inline">\(A\)</span> 并且高度小于等于 <span
class="math inline">\(B\)</span>
的所有套娃。你需要预先安排出一个方案，使送来的套娃经过若干次嵌套后，没有被套的套娃数量最小。</p>
<p>由于厂家经常搞大新闻，所以他会改变 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 的值，总共 <span
class="math inline">\(Q\)</span> 次，因此你需要对每对 <span
class="math inline">\((A,B)\)</span> 都作出回答，询问之间互不干扰。
<span id="more"></span> ## 输入</p>
<p>第一行有两个整数 <span class="math inline">\(N\)</span>和 <span
class="math inline">\(Q\)</span> ，表示套娃的个数和 <span
class="math inline">\((A,B)\)</span> 的对数； 之后的 <span
class="math inline">\(N\)</span> 行，每行两个数 <span
class="math inline">\(R_i\)</span> 与 <span
class="math inline">\(H_i\)</span> 表示第$ i$ 个数的直径和高度； 之后的
<span class="math inline">\(Q\)</span> 行，每行两个数 <span
class="math inline">\(A_i\)</span> 与 <span
class="math inline">\(B_i\)</span> 表示第 <span
class="math inline">\(i\)</span> 个询问， <span
class="math inline">\(A_i\)</span> 与 <span
class="math inline">\(B_i\)</span> 的意思如上所示。</p>
<h2 id="输出">输出</h2>
<p>一个整数，表示符合条件的方案个数。</p>
<h2 id="思路">思路</h2>
<h4 id="重要结论">重要结论</h4>
<p>这题每个套娃都是二维的，于是可以用<span
class="math inline">\(xy​\)</span>坐标轴表示所有的套娃，任意一个点只要在另一个点的右上方就可以把那点（娃娃）装进去</p>
<p><img src="/posts/16994/o_qwq3.png" /></p>
<p>（横坐标为R,纵坐标为H）</p>
<p>这题根据人类的智慧可以得到</p>
<p><strong>（直接）甩结论</strong>：最少的没被套的娃娃个数=最长的<span
class="math inline">\(R\)</span>递增，<span
class="math inline">\(H\)</span>递减的序列长度</p>
<p>这个可以感性理解一下，所有不在该序列上的点都必定会在一个点的右上方，所以就相当于所有多出来的点都是可以被装进另一个点中的。</p>
<h4 id="离线离散">离线+离散</h4>
<p>知道这个后就去考虑每个询问，对于每个询问，若逐个计算每次的答案，用一个树状数组其中一维，显然要将一维进行离散。那么剩下的一位直接考虑进行离线处理，那么复杂度就被用优化成<span
class="math inline">\(O((n+q)log_(n+q))\)</span>,可以开两个数组分别表示娃娃和询问，不过放一个数组里面一起排序会简单一些，不过注意在遇到询问和娃娃的两个值完全相同时，一定要先更新娃娃在回答询问（当时就被这个卡了。。。）</p>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,l,r) for(int i=(l),END=(r);i&lt;=END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOR(i,r,l) for(int i=(r),END=(l);i&gt;=END;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loop(i,n) for(int i=0,END=(n);i&lt;END;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf scanf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a,x) memset(a,x,sizeof a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chkmax</span><span class="params">(A &amp;x,<span class="type">const</span> B y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y)x=y;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chkmin</span><span class="params">(A &amp;x,<span class="type">const</span> B y)</span></span>&#123;<span class="keyword">if</span>(x&gt;y)x=y;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">pii doll[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pt2</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y,id;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A)<span class="type">const</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(x!=A.x)<span class="keyword">return</span> x&gt;A.x;</span><br><span class="line">			<span class="keyword">if</span>(y!=A.y)<span class="keyword">return</span> y&lt;A.y;</span><br><span class="line">			<span class="keyword">return</span> id&lt;A.id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;A[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> b[N&lt;&lt;<span class="number">1</span>],ans[N],ct;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Binary_Indexed_Tree</span>&#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-(x))</span></span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> M=<span class="number">4e5</span>;</span><br><span class="line">		<span class="type">int</span> c[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span>&#123;<span class="keyword">while</span>(x&lt;=M)<span class="built_in">chkmax</span>(c[x],val),x+=<span class="built_in">lowbit</span>(x);&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="type">int</span> ret=<span class="number">0</span>;<span class="keyword">while</span>(x)<span class="built_in">chkmax</span>(ret,c[x]),x-=<span class="built_in">lowbit</span>(x);<span class="keyword">return</span> ret;&#125;</span><br><span class="line">	&#125;BIT;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)b[++ct]=doll[i].H,A[i]=(node)&#123;doll[i].R,doll[i].H,<span class="number">0</span>&#125;;;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">			<span class="built_in">sf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;A[n+i].x,&amp;A[n+i].y);</span><br><span class="line">			A[n+i].id=i,b[++ct]=A[n+i].y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+ct+<span class="number">1</span>);</span><br><span class="line">		ct=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+ct+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">sort</span>(A+<span class="number">1</span>,A+n+q+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n+q)A[i].y=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+ct+<span class="number">1</span>,A[i].y)-b;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n+q)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i].id)ans[A[i].id]=BIT.<span class="built_in">query</span>(A[i].y);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> nw=BIT.<span class="built_in">query</span>(A[i].y);</span><br><span class="line">				BIT.<span class="built_in">update</span>(A[i].y,nw+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,q)<span class="built_in">pf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Pt_2;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>Tree（POJ-1741）</title>
    <url>/posts/37020.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>Give a tree with n vertices,each edge has a length(positive integer
less than 1001). Define dist(u,v)=The min distance between node u and v.
Give an integer k,for every pair (u,v) of vertices is called valid if
and only if dist(u,v) not exceed k. Write a program that will count how
many pairs which are valid for a given tree. <span id="more"></span> ## 输入 The
input contains several test cases. The first line of each test case
contains two integers n, k. (n&lt;=10000) The following n-1 lines each
contains three integers u,v,l, which means there is an edge between node
u and v of length l. The last test case is followed by two zeros.</p>
<h2 id="输出">输出</h2>
<p>For each test case output the answer on a single line.</p>
<h2 id="思路">思路：</h2>
<p>比较普遍的一道点分治题，<strong>考虑每一棵树，以重心为根，预处理出每个点的深度，再把每个点扔到一个数组中进行线性计算，算出满足条件的所有点对</strong>，方法可以是将其排序，用两个指针从两边往中间推着计算。</p>
<p>不过这时候会有小问题，会多算一种情况，就是<strong>他们的LCA不是重心的情况</strong>,这时候就需要采用容斥原理的思想，<strong>在每个重心的子树中计算一遍上述的操作</strong>(注意加上重心到根节点的距离)，再在答案中对应地减去，便能得到最终答案！</p>
<h4 id="代码">代码</h4>
<p>```c++ #include<cstdio> #include<cstring> #include<algorithm> using
namespace std; bool mem1; const int N=100005; struct Graph{ int
tot,to[N&lt;&lt;1],nxt[N&lt;&lt;1],len[N&lt;&lt;1],head[N]; void add(int
x,int y,int z){tot++;to[tot]=y;nxt[tot]=head[x];len[tot]=z;head[x]=tot;}
void clear(){tot=0;memset(head,-1,sizeof(head));} }G; bool vis[N]; int
ans,sz[N],mx[N],t_sz,center; int arr[N],dep[N]; int n,k; bool mem2; void
make_dep(int x,int f){ arr[++arr[0]]=dep[x]; for(int
i=G.head[x];i!=-1;i=G.nxt[i]){ int v=G.to[i]; if(v==f||vis[v])continue;
dep[v]=dep[x]+G.len[i]; make_dep(v,x); } } void get_center(int x,int f){
sz[x]=1,mx[x]=0; for(int i=G.head[x];i!=-1;i=G.nxt[i]){ int v=G.to[i];
if(v==f||vis[v])continue; get_center(v,x); sz[x]+=sz[v];
mx[x]=max(mx[x],sz[v]); } mx[x]=max(mx[x],t_sz-sz[x]);
if(!center||mx[x]&lt;mx[center])center=x; } int calc(int x,int dis){
dep[x]=dis,arr[0]=0; make_dep(x,0); sort(arr+1,arr+arr[0]+1); int
j=arr[0],ret=0; for(int i=1;i&lt;=arr[0];i++){
while(j&gt;i&amp;&amp;arr[i]+arr[j]&gt;k)j–; ret+=max(0,j-i); } return
ret; } void solve(int x){ vis[x]=1; ans+=calc(x,0); for(int
i=G.head[x];i!=-1;i=G.nxt[i]){ int v=G.to[i]; if(vis[v])continue;
ans-=calc(v,G.len[i]); center=0,t_sz=sz[v]; get_center(v,x);
solve(center); } } int main(){ while(scanf(“%d%d”,&amp;n,&amp;k)==2){
if(!n&amp;&amp;!k)break; G.clear(); memset(vis,0,sizeof vis); for(int
i=1;i&lt;n;i++){ int x,y,z; scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z);
G.add(x,y,z),G.add(y,x,z); } center=0,t_sz=n,ans=0; get_center(1,0);
solve(center); printf(“%d”,ans); } return 0; }</p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>二分图&amp;&amp;匈牙利算法（二分图基本算法）</title>
    <url>/posts/22307.html</url>
    <content><![CDATA[<h1 id="二分图">二分图</h1>
<h4
id="二分图又称作二部图是图论中的一种特殊模型">二分图又称作二部图，是图论中的一种特殊模型。</h4>
<p>设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i
in A,j in B)，则称图G为一个二分图。 <span id="more"></span> ####
区别二分图，关键是看点集是否能分成两个独立的点集。如下图所示 <img
src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=6f1eefd3d53f8794c7f2407cb3726591/3c6d55fbb2fb43169079761121a4462309f7d373.jpg" /></p>
<h2 id="二分图的最大匹配">二分图的最大匹配</h2>
<p><strong>给定一个二分图G，在G的一个子图M中，M的边集中的任意两条边都不依附于同一个顶点，则称M是一个匹配.</strong>
选择这样的边数最大的子集称为图的最大匹配问题（maximal matching problem)
如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。</p>
<h2
id="求最大匹配的方法常用的有匈牙利算法">求最大匹配的方法，常用的有匈牙利算法</h2>
<h1 id="匈牙利算法">匈牙利算法</h1>
<p>主要思路就是枚举一个点集中的所有点x，对于每个点x，枚举以其为端点的所有点v，若v未被匹配则将x匹配给v，<strong>若v已有一点与其匹配，则判断原来匹配给它的点x1是否有其他的点v1可以匹配</strong>,就这样一直递归下去，当跑完整个流程时，得到的匹配成功的x数则是二分图的最大匹配！代码如下
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mk[x]表示点x所匹配的点，mark[x]表示x已被走过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> v=eedge[x][i];</span><br><span class="line">        <span class="keyword">if</span>(mark[v])<span class="keyword">continue</span>;</span><br><span class="line">        mark[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mk[v]==<span class="number">-1</span>||<span class="built_in">sp</span>(mk[v]))&#123;</span><br><span class="line">            mk[v]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(mk,<span class="number">-1</span>,<span class="built_in">sizeof</span>(mk));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n；i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="built_in">sizeof</span>(mark));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sp</span>(i))ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二分图的最小顶点覆盖">二分图的最小顶点覆盖</h2>
<blockquote>
<p>定理：二分图的最小顶点覆盖等于其最大匹配值</p>
</blockquote>
<p>个人是用归纳去理解这理论，首先当只有一个点时，结论肯定成立，当有x个点的二分图时满足条件，假如多增了一个点连向另一点集中的若干个点时，若该点匹配成功，说明这条边是原来的点无法覆盖到的，必须把新增的点选入才能覆盖到新增的边，否则不许选入（自行理解）</p>
<h2 id="二分图的最大独立集">二分图的最大独立集</h2>
<blockquote>
<p>定理：二分图的最大独立集=总点数-最小顶点覆盖</p>
</blockquote>
<p>这个较好理解，假设把最小顶点覆盖的点移除图外，剩下的图中是不存在一条边的</p>
<h2 id="二分图的最大团">二分图的最大团</h2>
<blockquote>
<p>定理：二分图的最大团=补图的最大团</p>
</blockquote>
<p>补图的定义是：对于二分图中左边一点x和右边一点y，若x和y之间有边，那么在补图中没有，否则有。<br />
这个方法很好理解，因为最大独立集是两两不相邻，所以最大独立集的补图两两相邻。</p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>过山车（HDU-2063）</title>
    <url>/posts/15020.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>RPG
girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？
<span id="more"></span> ## 输入 输入数据的第一行是三个整数<strong>K</strong> ,
<strong>M</strong> ,
<strong>N</strong>，分别表示可能的组合数目，女生的人数，男生的人数。<strong>0&lt;K&lt;=1000</strong>
<strong>1&lt;=N</strong>
和<strong>M&lt;=500</strong>.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个<strong>0</strong>结束输入。</p>
<h2 id="输出">输出</h2>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
<h2 id="思路">思路：</h2>
<p>做的第一道二分图题，模板题，就是一个匈牙利算法的简单应用。。用于加深对着算法的作用，功能的影响。。。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">505</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[maxn+maxn];</span><br><span class="line"><span class="type">int</span> mk[maxn+maxn],n,m,ans;</span><br><span class="line"><span class="type">bool</span> mark[maxn+maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sp</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;e[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[x][i];</span><br><span class="line">		<span class="keyword">if</span>(mark[v])<span class="keyword">continue</span>;</span><br><span class="line">		mark[v]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mk[v]==<span class="number">-1</span>||<span class="built_in">sp</span>(mk[v])) &#123;</span><br><span class="line">			mk[v]=x;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="built_in">sizeof</span>(mark));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sp</span>(i))ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k)==<span class="number">1</span>) &#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)e[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">memset</span>(mk,<span class="number">-1</span>,<span class="built_in">sizeof</span>(mk));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line">			<span class="type">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>点分治</title>
    <url>/posts/49220.html</url>
    <content><![CDATA[<blockquote>
<p>树上的分治分两种：<strong>点分治</strong>和<strong>边分治</strong>，点分治由于其比较稳定的复杂度，是两者中更为常用的一种。</p>
</blockquote>
<h3 id="点分治">点分治</h3>
<p>顾名思义，就是将树用重心分割为几块，然后在每棵树中进行类似“暴力”的操作，已达到复杂度优化的作用
重心,即一棵树上的一个点，以其作为根，其最大子树大小最小的点</p>
<h3 id="复杂度">复杂度</h3>
<p>考虑最坏情况，一个重心只有两个子树，那么当你如此分割时，两颗子树的大小都大概是原树大小的一半左右，若在每棵树中的操作都是O(n)的话，最后复杂度便为O(nlogn)，然而这是最坏情况，若平均起来，会比它还小一些，可见它是十分有效的。
<span id="more"></span></p>
<h3 id="模板">模板</h3>
<p>首先是找到树的重心，比较简单，一个深搜便能解决</p>
<h6 id="伪代码">伪代码：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">get_center</span>(<span class="type">int</span> x,<span class="type">int</span> fa)&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span></span><br><span class="line">    mx[x]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> edge in x</span><br><span class="line">        v=edge.to</span><br><span class="line">        <span class="keyword">if</span> v!=fa <span class="keyword">and</span> vis[v]==<span class="number">0</span></span><br><span class="line">            <span class="built_in">get_center</span>(v,x)</span><br><span class="line">            siz[x]+=siz[v]</span><br><span class="line">            <span class="keyword">if</span> mx[x]&gt;siz[v] </span><br><span class="line">                mx[x]=siz[v]</span><br><span class="line">    <span class="keyword">if</span> t_sz-siz[x]&gt;mx[x]</span><br><span class="line">        mx[x]=t_sz-siz[x]</span><br><span class="line">   <span class="keyword">if</span> center==<span class="number">0</span> <span class="keyword">or</span> mx[center]&gt;mx[x]</span><br><span class="line">       center=x     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里应该都能看出，<span
class="math inline">\(center\)</span>就是重心，<span
class="math inline">\(t_{sz}\)</span>是整棵树的大小，其实就是递归求出所有子树的大小，再取最大值，同时不要忘了以父亲为根的子树
再然后就是<span class="math inline">\(vis\)</span>，<span
class="math inline">\(vis\)</span>数组就相当于上面提到的分割点，也就是这个点已经被当做重心计算过了，不能递归走回去，所以也要判掉</p>
<p>接下来就是<strong>dfs</strong>了</p>
<h6 id="伪代码-1">伪代码：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(<span class="type">int</span> x)&#123;<span class="comment">//x便是重心</span></span><br><span class="line">    vis[x]=<span class="number">1</span></span><br><span class="line">    <span class="built_in">work</span>(x)</span><br><span class="line">    <span class="keyword">for</span> edge in x</span><br><span class="line">        v=edge.to</span><br><span class="line">        <span class="built_in">work</span>(v)</span><br><span class="line">        <span class="keyword">if</span> v!=fa <span class="keyword">and</span> vis[v]==<span class="number">0</span></span><br><span class="line">            center=<span class="number">0</span></span><br><span class="line">            t_sz=siz[v]</span><br><span class="line">           <span class="built_in">get_center</span>(v,x)</span><br><span class="line">           <span class="built_in">dfs</span>(center) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较直观了，每次递归到一个重心后，将其用<span
class="math inline">\(vis\)</span>标记掉，这样接下来的<span
class="math inline">\(work\)</span>就是一道点分治题的精髓了，它代表你在当前的树中进行的操作或计算，在不同的题目中它的内容都不同。有时只<strong>work</strong>子树，有时根和子树都<strong>work</strong>，十分多变。</p>
<p>接下就是求出每个子树的<span class="math inline">\(center\)</span>，
在递归下去继续计算即可！</p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
  <entry>
    <title>敌兵布阵（HDU-1166）</title>
    <url>/posts/42090.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述：</h2>
<p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。
中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:“你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：“我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.
<span id="more"></span> ## 输入 第一行一个整数T，表示有T组数据。
每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。
接下来每行有一条命令，命令有4种形式： (1) Add i
j,i和j为正整数,表示第i个营地增加j个人（j不超过30） (2)Sub i j
,i和j为正整数,表示第i个营地减少j个人（j不超过30）; (3)Query i j
,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数; (4)End
表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令</p>
<h2 id="输出">输出</h2>
<p>对第i组数据,首先输出“Case i:”和回车,
对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</p>
<h2 id="思路">思路：</h2>
<p>最近刚学的三个最新的数据结构都可以写这题，可以说这题很经典吧！不管对于那种数据结构都很典型，也能体现每种数据结构的特点，下面一一解释：</p>
<h4 id="分块">分块：</h4>
<p>由于每次询问时都要查询一个区间的和，若每次都扫描一遍，肯定会超时，那么换一种想法，若将整个区间划分为若干个小块，存下他们的和，当访问一个区间时，其中包含的所有完整的小块便可直接O(1)查询和，至于两边多余的部分便可以暴力求和了，至于更新，则只需额外再修改一下该点所在的块的和即可。</p>
<h4 id="树状数组">树状数组：</h4>
<p>树状数组我觉得是三个数据结构中最难理解的，咳咳。。比如有一个长度为6的数组，二进制表示为110，此时可以将其拆分为110=100+10，进行处理，至于如何拆分，用lowbit即可，这样只需预处理出所有这样形式的和即可，这样做大大减少了复杂度，至于如何实现，可见下方代码。</p>
<h4 id="线段树">线段树：</h4>
<p>这种方法就比较套路了，将（1-n）的数组，划分为一棵二叉树，分割为一个个小区间，分别存在每个子树（或叶子）中，最后查询时用树形遍历即可，这样的复杂度也会大大减少。线段树的大致结构为，build()函数建树，update()函数更新结构，最后query()函数查询信息，三个函数的写法都十分相似，但要学会区分。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分块做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">50005</span>,S=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],sum[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> pl=l/S,pr=r/S,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(pl==pr)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">			ans+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;(pl+<span class="number">1</span>)*S;i++)ans+=a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=pr*S;i&lt;=r;i++)ans+=a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=pl+<span class="number">1</span>;i&lt;pr;i++)ans+=sum[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="type">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=sum[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">			tot+=a[i];</span><br><span class="line">			<span class="keyword">if</span>(i%S==S<span class="number">-1</span>)sum[i/S]=tot,tot=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,++kase);</span><br><span class="line">		<span class="type">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			x--,y--;</span><br><span class="line">			<span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">				y++;</span><br><span class="line">				<span class="type">int</span> px=x/S;</span><br><span class="line">				a[x]+=y;</span><br><span class="line">				sum[px]+=y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">				y++;</span><br><span class="line">				<span class="type">int</span> px=x/S;</span><br><span class="line">				a[x]-=y;</span><br><span class="line">				sum[px]-=y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树状数组写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],c[maxn],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下两个函数很重要，要完全理解。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		ans+=c[x];</span><br><span class="line">		x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">		c[x]+=y;</span><br><span class="line">		x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),<span class="built_in">update</span>(i,a[i]);</span><br><span class="line">		<span class="type">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,++kase);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			<span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">update</span>(x,y);</span><br><span class="line">				a[x]+=y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">update</span>(x,-y);</span><br><span class="line">				a[x]+=y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(y)-<span class="built_in">sum</span>(x<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> a[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum;</span><br><span class="line">&#125;tree[M*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	tree[p].sum=tree[p&lt;&lt;<span class="number">1</span>].sum+tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下三个函数十分重要，要完全理解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	tree[p].l=l,tree[p].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[p].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(l,mid,<span class="number">2</span>*p);</span><br><span class="line">	<span class="built_in">build</span>(mid+<span class="number">1</span>,r,<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> a,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[p].l==tree[p].r)&#123;</span><br><span class="line">		tree[p].sum+=a;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)<span class="built_in">add</span>(x,a,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">add</span>(x,a,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;%d %d %d\n&quot;,l,r,p);</span></span><br><span class="line">	<span class="keyword">if</span>(tree[p].l==l&amp;&amp;tree[p].r==r)&#123;</span><br><span class="line">		<span class="keyword">return</span> tree[p].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(l,r,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(l,r,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(l,mid,p&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(mid+<span class="number">1</span>,r,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,++kase);</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		<span class="type">char</span> cmd[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			<span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">add</span>(x,y,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">add</span>(x,-y,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y,<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
</search>

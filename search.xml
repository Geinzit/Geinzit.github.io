<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>点分治</title>
    <url>/posts/49220.html</url>
    <content><![CDATA[<blockquote>
<p>树上的分治分两种：<strong>点分治</strong>和<strong>边分治</strong>，点分治由于其比较稳定的复杂度，是两者中更为常用的一种。</p>
</blockquote>
<h3 id="点分治">点分治</h3>
<p>顾名思义，就是将树用重心分割为几块，然后在每棵树中进行类似“暴力”的操作，已达到复杂度优化的作用
重心,即一棵树上的一个点，以其作为根，其最大子树大小最小的点</p>
<h3 id="复杂度">复杂度</h3>
<p>考虑最坏情况，一个重心只有两个子树，那么当你如此分割时，两颗子树的大小都大概是原树大小的一半左右，若在每棵树中的操作都是O(n)的话，最后复杂度便为O(nlogn)，然而这是最坏情况，若平均起来，会比它还小一些，可见它是十分有效的。</p>
<h3 id="模板">模板</h3>
<p>首先是找到树的重心，比较简单，一个深搜便能解决</p>
<h6 id="伪代码">伪代码：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">get_center</span>(<span class="type">int</span> x,<span class="type">int</span> fa)&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span></span><br><span class="line">    mx[x]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> edge in x</span><br><span class="line">        v=edge.to</span><br><span class="line">        <span class="keyword">if</span> v!=fa <span class="keyword">and</span> vis[v]==<span class="number">0</span></span><br><span class="line">            <span class="built_in">get_center</span>(v,x)</span><br><span class="line">            siz[x]+=siz[v]</span><br><span class="line">            <span class="keyword">if</span> mx[x]&gt;siz[v] </span><br><span class="line">                mx[x]=siz[v]</span><br><span class="line">    <span class="keyword">if</span> t_sz-siz[x]&gt;mx[x]</span><br><span class="line">        mx[x]=t_sz-siz[x]</span><br><span class="line">   <span class="keyword">if</span> center==<span class="number">0</span> <span class="keyword">or</span> mx[center]&gt;mx[x]</span><br><span class="line">       center=x     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里应该都能看出，<span
class="math inline">\(center\)</span>就是重心，<span
class="math inline">\(t_{sz}\)</span>是整棵树的大小，其实就是递归求出所有子树的大小，再取最大值，同时不要忘了以父亲为根的子树
再然后就是<span class="math inline">\(vis\)</span>，<span
class="math inline">\(vis\)</span>数组就相当于上面提到的分割点，也就是这个点已经被当做重心计算过了，不能递归走回去，所以也要判掉</p>
<p>接下来就是<strong>dfs</strong>了</p>
<h6 id="伪代码-1">伪代码：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(<span class="type">int</span> x)&#123;<span class="comment">//x便是重心</span></span><br><span class="line">    vis[x]=<span class="number">1</span></span><br><span class="line">    <span class="built_in">work</span>(x)</span><br><span class="line">    <span class="keyword">for</span> edge in x</span><br><span class="line">        v=edge.to</span><br><span class="line">        <span class="built_in">work</span>(v)</span><br><span class="line">        <span class="keyword">if</span> v!=fa <span class="keyword">and</span> vis[v]==<span class="number">0</span></span><br><span class="line">            center=<span class="number">0</span></span><br><span class="line">            t_sz=siz[v]</span><br><span class="line">           <span class="built_in">get_center</span>(v,x)</span><br><span class="line">           <span class="built_in">dfs</span>(center) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较直观了，每次递归到一个重心后，将其用<span
class="math inline">\(vis\)</span>标记掉，这样接下来的<span
class="math inline">\(work\)</span>就是一道点分治题的精髓了，它代表你在当前的树中进行的操作或计算，在不同的题目中它的内容都不同。有时只<strong>work</strong>子树，有时根和子树都<strong>work</strong>，十分多变。</p>
<p>接下就是求出每个子树的<span class="math inline">\(center\)</span>，
在递归下去继续计算即可！</p>
]]></content>
      <categories>
        <category>OI-related</category>
      </categories>
  </entry>
</search>
